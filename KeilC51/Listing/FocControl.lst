C51 COMPILER V9.52.0.0   FOCCONTROL                                                        04/16/2020 10:07:49 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE FOCCONTROL
OBJECT MODULE PLACED IN .\Output\FocControl.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\User\Source\Function\FocControl.c LARGE OMF2 WARNINGLEVEL(0) OPTIMIZE(5
                    -,SPEED) BROWSE INCDIR(..\Library\FU68xx_Hardware_Driver\Include;..\User\Include) DEBUG PRINT(.\Listing\FocControl.lst) T
                    -ABS(2) OBJECT(.\Output\FocControl.obj)

line level    source

   1          /**************************** (C) COPYRIGHT 2017 Fortiortech shenzhen *****************************
   2          * File Name          : FocControl.c
   3          * Author             : Fortiortech  Appliction Team
   4          * Version            : V1.0
   5          * Date               : 2017-12-26
   6          * Description        : This file contains all the foc control framework used for Motor Control.
   7          ***************************************************************************************************
   8          * All Rights Reserved
   9          **************************************************************************************************/
  10          
  11          
  12          /* Includes -------------------------------------------------------------------------------------*/
  13          // #include <FocControl.h>
  14          #include <FU68xx_2.h>
  15          #include <Myproject.h>
  16          
  17          /* Private variables ----------------------------------------------------------------------------*/
  18          MotStaType mcState;
  19          //MotStaTim  MotorStateTime;
  20          MotStaM    McStaSet;
  21          //TailWindSet xdata  mcTailwind;
  22          
  23          uint16 TimeCnt;
  24          
  25          //uint16 EFREQACC;
  26          //uint16 EFREQMIN;
  27          //uint16 EFREQHOLD;
  28          
  29          StartTimeCnt Time;
  30          
  31          /*---------------------------------------------------------------------------*/
  32          /* Name     :   void MC_Control(void)
  33          /* Input    :   NO
  34          /* Output   :   NO
  35          /* Description: ç”µæœºçŠ¶æ€æœºå‡½æ•°ï¼ŒåŒ…æ‹¬åˆå§‹åŒ–ã€é¢„å……ç”µã€é¡ºé£é€†é£åˆ¤æ–­ã€é¢„å®šä½ã€å¯
             -åŠ¨ã€è¿è¡Œã€æ•…éšœç­‰
  36          /*---------------------------------------------------------------------------*/
  37          void MC_Control(void)
  38          {
  39   1        switch(mcState)
  40   1        {
  41   2          case mcReady:    // å…³é—­è¾“å‡º,ä¸Šç”µä¼šå¯¹ç”µæµè¿›è¡Œé‡‡é›†æ ¡å‡†,å½“é‡‡æ ·æ ¡å‡†ç»“æŸæ ‡å¿—ç½®1ä¸”
             -å¯åŠ¨æŒ‡ä»¤ç½®1åï¼Œæ‰è·³è½¬åˆ°mcInit
  42   2            Motor_Ready();
  43   2          
  44   2            if((mcCurOffset.OffsetFlag == 1) && (mcSpeedRamp.FlagONOFF == 1) && (mcFocCtrl.State_Count == 0)) 
  45   2            {
  46   3                mcState = mcInit;
  47   3                FOC_EFREQACC  = 0;               
  48   3                FOC_EFREQMIN  = 0;
  49   3      //          FOC_EFREQMIN  = Motor_Omega_Ramp_Min;
  50   3                FOC_EFREQHOLD = 0;
  51   3            }
C51 COMPILER V9.52.0.0   FOCCONTROL                                                        04/16/2020 10:07:49 PAGE 2   

  52   2          break;
  53   2      
  54   2          case mcInit:                          // åˆå§‹åŒ–çŠ¶æ€ï¼Œè¿›å…¥mcChargeçŠ¶æ€
  55   2            Motor_Init();
  56   2            mcState               =  mcCharge;               // è·³å…¥mcChargeçŠ¶æ€
  57   2            mcFocCtrl.State_Count = Charge_Time;
  58   2            mcFocCtrl.TPCtrlDealy = 1000;                     //ç”µæœºæ­£å¸¸è¿è¡Œ500msåå†å¼€å‘çƒ­ä¸
  59   2          break;
  60   2      
  61   2          case mcCharge:                        // é¢„å……ç”µçŠ¶æ€ï¼ŒMCUè¾“å‡ºå›ºå®šé¢‘ç‡å ç©ºæ¯”ï¼Œé¢„å……ç”µç»“
             -æŸåï¼Œè·³å…¥mcTailWind
  62   2            Motor_Charge();
  63   2            #if (IPMState == NormalRun)           // æ­£å¸¸æŒ‰ç”µæœºçŠ¶æ€æœºè¿è¡Œ
  64   2              if( mcFocCtrl.State_Count == 0)
  65   2              {
  66   3                  MOE = 0;                      // å…³é—­è¾“å‡º
  67   3      
  68   3                  mcState               = mcTailWind;
  69   3                  mcFocCtrl.State_Count = 0;
  70   3              }
  71   2      
  72   2            #endif
  73   2          break;
  74   2      
  75   2          case mcTailWind:
  76   2            #if (TailWind_Mode == NoTailWind)     // æ— é¡ºé€†é£å¤„ç†çš„ï¼Œç›´æ¥è·³å…¥ä¸‹ä¸€ä¸ªçŠ¶æ€
  77   2              mcState                           = mcPosiCheck;
  78   2              McStaSet.SetFlag.PosiCheckSetFlag = 0;
  79   2              mcFocCtrl.mcPosCheckAngle         = 0xffff;         // è§’åº¦èµ‹åˆå€¼
  80   2      
  81   2            #elif (TailWind_Mode == TailWind)
                      Motor_TailWind();
              
                    #endif
  85   2          break;
  86   2      
  87   2          case mcPosiCheck:
  88   2            #if (PosCheckEnable==0)             //åˆå§‹ä½ç½®æ£€æµ‹ä¸ä½¿èƒ½æ—¶åˆå§‹è§’åº¦ä¸ºé¢„å®šä½è§’åº¦
                      mcFocCtrl.mcPosCheckAngle = Align_Angle;
                      mcState = mcAlign;
                      mcFocCtrl.State_Count = Align_Time;
              
                    #else
  94   2              RPD();
  95   2      
  96   2            #endif
  97   2          break;
  98   2      
  99   2          case mcAlign:       // é¢„å®šä½æ—¶é—´ç»“æŸåï¼Œç›´æ¥å¯åŠ¨; AlignTestMode=1ç”¨äºåˆå§‹ä½ç½®æ£€æµ‹è
             -°ƒè¯•ç”¨
 100   2            Motor_Align();
 101   2      
 102   2            
 103   2            #if (AlignTestMode==1)
                        while(1);
              
                    #else
 107   2                if(mcFocCtrl.State_Count == 0)
 108   2                {
 109   3                  mcState = mcStart;
 110   3                }
 111   2      
C51 COMPILER V9.52.0.0   FOCCONTROL                                                        04/16/2020 10:07:49 PAGE 3   

 112   2            #endif
 113   2          break;
 114   2      
 115   2          case mcStart:                           // é…ç½®ç”µæœºå¯åŠ¨å‚æ•°ï¼Œè¿›å…¥mcRunçŠ¶æ€ã€‚
 116   2            Motor_Open();
 117   2          break;
 118   2      
 119   2          case mcPllTect:                           // é…ç½®ç”µæœºå¯åŠ¨å‚æ•°ï¼Œè¿›å…¥mcRunçŠ¶æ€ã€‚
 120   2            #if (EstimateAlgorithm == PLL)
                        Motor_PllStart();
              
                    #endif
 124   2          break;
 125   2      
 126   2          case mcRun:                             // è¿è¡ŒçŠ¶æ€ï¼Œè‹¥è¿è¡ŒçŠ¶æ€çš„ç»™å®šå˜ä¸º0ï¼Œè¿›å…¥mcStop
             -çŠ¶æ€ã€‚
 127   2            if(mcSpeedRamp.TargetValue == 0)//&&(mcSpeedRamp.ActualValue < Motor_Min_Speed))
 128   2            {
 129   3                mcState               = mcStop;
 130   3      //          mcFocCtrl.State_Count = 2000;
 131   3                FOC_IQREF             = 0;
 132   3            }
 133   2          break;
 134   2      
 135   2          case mcStop:
 136   2            if((mcFocCtrl.SpeedFlt < Motor_Min_Speed)||(mcFocCtrl.State_Count==0))    // å®é™…è½¬é€Ÿä½äºMotor_Min_
             -Speedæˆ–å»¶æ—¶åˆ°äº†ï¼Œå…³é—­PWMè¾“å‡ºæˆ–è¿›å…¥åˆ¹è½¦
 137   2            {
 138   3              #if (StopBrakeFlag == 0)
 139   3              {
 140   4                  FOC_CR1 = 0x00;
 141   4                  /*å…³é—­FOC*/
 142   4                  ClrBit(DRV_CR, FOCEN);
 143   4        
 144   4                  mcState = mcReady;
 145   4              }
 146   3              #else
                      {
                          if(mcFocCtrl.SpeedFlt < Motor_Stop_Speed)                           // ä½äºStopSpeed,åˆ¹è½¦
                          {
                              MOE = 0;
                              FOC_CR1 = 0x00;
                              ClrBit(DRV_CR, FOCEN);
                              DRV_DR  = DRV_ARR+1;
                              DRV_CMR &= 0xFFC0;
                              DRV_CMR |= 0x015;                                               // ä¸‰ç›¸ä¸‹æ¡¥è‡‚é€šï¼Œåˆ¹è½¦
                              ClrBit(DRV_CR, OCS);                                            // OCS = 0, DRV_COMR;OCS = 1, FOC/SVPWM/SPWM
                              MOE = 1;
                              mcState               = mcBrake;
                              mcFocCtrl.State_Count = StopWaitTime;
                          }
                      }
                      #endif
 163   3            }
 164   2            else if(mcSpeedRamp.TargetValue > 0)                                      // StopçŠ¶æ€æ—¶ï¼Œç”µæœºåœ¨å‡é€ŸçŠ¶æ€ï¼Œåˆå¼
             -€æœºè¿›å…¥æ­£å¸¸è¿è¡Œæ¨¡å¼
 165   2            {
 166   3                mcState            = mcRun;
 167   3                mcFocCtrl.CtrlMode = 0;
 168   3                FOC_IQREF          = IQ_RUN_CURRENT;
 169   3            }
 170   2          break;
C51 COMPILER V9.52.0.0   FOCCONTROL                                                        04/16/2020 10:07:49 PAGE 4   

 171   2      
 172   2          case mcBrake:
 173   2            if(mcFocCtrl.State_Count == 0)
 174   2            {
 175   3                MOE=0;
 176   3                ClrBit(DRV_CR, FOCEN);
 177   3                mcState = mcReady;
 178   3            }
 179   2          break;
 180   2      
 181   2          case mcFault:
 182   2          break;
 183   2        }
 184   1      }
 185          
 186          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    361    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
