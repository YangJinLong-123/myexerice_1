C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE ADDFUNCTION
OBJECT MODULE PLACED IN .\Output\AddFunction.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\User\Source\Application\AddFunction.c LARGE OMF2 WARNINGLEVEL(0) OPTIMI
                    -ZE(5,SPEED) BROWSE INCDIR(..\Library\FU68xx_Hardware_Driver\Include;..\User\Include) DEBUG PRINT(.\Listing\AddFunction.l
                    -st) TABS(2) OBJECT(.\Output\AddFunction.obj)

line level    source

   1          /**************************** (C) COPYRIGHT 2017 Fortiortech shenzhen *****************************
   2          * File Name          : AddFunction.c
   3          * Author             : Fortiortech  Appliction Team
   4          * Version            : V1.0
   5          * Date               : 2017-12-26
   6          * Description        : This file contains all the add function used for Motor Control.
   7          ***************************************************************************************************
   8          * All Rights Reserved
   9          **************************************************************************************************/
  10          
  11          
  12          /* Includes -------------------------------------------------------------------------------------*/
  13          // #include <AddFunction.h>
  14          #include <FU68xx_2.h>
  15          #include <Myproject.h>
  16          
  17          /* Private variables ---------------------------------------------------------*/
  18          FaultStateType             mcFaultSource;
  19          PWMINPUTCAL        idata   mcPwmInput;
  20          FaultVarible       idata   mcFaultDect;
  21          MotorRSDTypeDef    idata   RSDDetect;
  22          CurrentVarible     idata   mcCurVarible;
  23          ProtectVarible     idata   mcProtectTime;
  24          
  25          OUTLOOP            xdata   SpeedPICtrl;
  26          FOCCTRL            xdata   mcFocCtrl;
  27          ADCSample          xdata   AdcSampleValue;
  28          ONVarible          xdata   ONOFFTest;
  29          MCLedDisplay       xdata   mcLedDisplay;
  30          MCRAMP             xdata   mcSpeedRamp;
  31          SLEEPMODE          xdata   SleepSet;
  32          MotorFRTypeDef     xdata   mcFRState;
  33          int16              xdata   VSP;
  34          
  35          const int16  PowerGiven[10] ={0,500,1000,2200,2900,4300,5900,7300,7900,8550};
  36          
  37          extern char Flag_Key1Value;
  38          extern char Flag_Key2Value;
  39          
  40          uint8 low_flag = 0;
  41          
  42          /*---------------------------------------------------------------------------*/
  43          /* Name     :   void OutLoopParameterSet(void)
  44          /* Input    :   NO
  45          /* Output   :   NO
  46          /* Description: 
  47          /*---------------------------------------------------------------------------*/
  48          void OutLoopParameterSet(void)
  49          {
  50   1        memset(&SpeedPICtrl,0, sizeof(OUTLOOP));                                // SpeedControl clear
  51   1      
  52   1        mcFocCtrl.SpeedLoopTime = SPEED_LOOP_TIME;
  53   1        mcFocCtrl.SpeedRampTime = SPEEDRAMPTIME;
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 2   

  54   1        
  55   1        mcSpeedRamp.IncValue    = SPEEDRAMPSTARTINC;
  56   1        mcSpeedRamp.DecValue    = SPEEDRAMPSTARTDEC;
  57   1      
  58   1        SpeedPICtrl.ExtKP       = SKP;
  59   1        SpeedPICtrl.ExtKI       = SKI;
  60   1        SpeedPICtrl.ExtOutMax   = SOUTMAX;
  61   1        SpeedPICtrl.ExtOutMin   = SOUTMIN;
  62   1        
  63   1        PI_KP     = SpeedPICtrl.ExtKP;
  64   1        PI_KI     = SpeedPICtrl.ExtKI;
  65   1        PI_UKMAX  = SpeedPICtrl.ExtOutMax;
  66   1        PI_UKMIN  = SpeedPICtrl.ExtOutMin;
  67   1        
  68   1      //  PI_UK     = I_Value(0.4) ;
  69   1        FOC_IQREF = I_Value(0.07);
  70   1        
  71   1        PI_UK     = FOC_IQREF ; 
  72   1      }
  73          /*---------------------------------------------------------------------------*/
  74          /* Name   : int16 KLPF_VALUE(int16 INVlaue, int16 OutLastValue)
  75          /* Input  : INVlaueÔºåOutLastValue
  76          /* Output : int16ÁöÑÂèòÈáè
  77          /* Description: Êª§Ê≥¢ÂáΩÊï∞,Áî®‰πòÊ≥ïÂô®ÂÅöÁöÑ
  78          /*---------------------------------------------------------------------------*/
  79          int16 KLPF_VALUE(int16 INVlaue, int16 OutLastValue)
  80          {
  81   1        int16 Result = 0;
  82   1        MDU_MA = (INVlaue-OutLastValue);
  83   1        MDU_MB = (int16)480;                    /*ÂÜôË¢´‰πòÊï∞Âíå‰πòÊï∞*/
  84   1      
  85   1        Result = MDU_MB;
  86   1        Result += OutLastValue;
  87   1        return(Result);
  88   1      }
  89          
  90          /*---------------------------------------------------------------------------*/
  91          /* Name   : void FaultProcess(void)
  92          /* Input  : NO
  93          /* Output : NO
  94          /* Description: ‰øùÊä§Â§ÑÁêÜÂáΩÊï∞ÔºåÂÖ≥Èó≠FOCËæìÂá∫ÔºåÂêåÊó∂Â∞ÜÁä∂ÊÄÅÂèò‰∏∫mcFault
  95          /*---------------------------------------------------------------------------*/
  96          void FaultProcess(void)
  97          {
  98   1        MOE     = 0;
  99   1        ClrBit(DRV_CR, FOCEN);  //ÂÖ≥Èó≠FOC
 100   1        mcState = mcFault;
 101   1      
 102   1      }
 103          
 104          /*---------------------------------------------------------------------------*/
 105          /* Name   : int16 Abs_F16(int16 value)
 106          /* Input  : value
 107          /* Output : int16
 108          /* Description: ÂØπÂèòÈáèÂèñ16‰ΩçÁöÑÁªùÂØπÂÄº
 109          /*---------------------------------------------------------------------------*/
 110          uint16 Abs_F16(int16 value)
 111          {
 112   1        if(value < 0)
 113   1        {
 114   2          return (- value);
 115   2        }
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 3   

 116   1        else
 117   1        {
 118   2          return (value);
 119   2        }
 120   1      }
 121          /*---------------------------------------------------------------------------*/
 122          /* Name   : int32 Abs_F32(int32 value)
 123          /* Input  : value
 124          /* Output : int16
 125          /* Description: ÂØπÂèòÈáèÂèñ16‰ΩçÁöÑÁªùÂØπÂÄº
 126          /*---------------------------------------------------------------------------*/
 127          uint32 Abs_F32(int32 value)
 128          {
 129   1        if(value < 0)
 130   1        {
 131   2          return (- value);
 132   2        }
 133   1        else
 134   1        {
 135   2          return (value);
 136   2        }
 137   1      }
 138          /*---------------------------------------------------------------------------*/
 139          /* Name   : void APP_DIV(void)
 140          /* Input  : void
 141          /* Output : void
 142          /* Description: Â∞ÜÊâÄÊúâÁî®Âà∞Èô§Ê≥ïÁöÑÂú∞ÊñπÔºåÊîæÂú®Âêå‰∏Ä‰∏™‰∏≠Êñ≠Ôºå‰ª•ÈÅøÂÖç‰∏≠Êñ≠‰∏≤Êâ∞
 143          /*---------------------------------------------------------------------------*/
 144          void APP_DIV(void)
 145          {
 146   1          if( mcPwmInput.PWMDivFlag==1)  //ÂêØÂä®Èô§Ê≥ïÂô®ÔºåÈÅøÂÖç‰∏éËøáË∞ÉÂÄº‰∏≠ÁöÑÈô§Ê≥ïÂÜ≤Á™Å
 147   1          {
 148   2             mcPwmInput.PWMDuty = MDU_DIV_IDATA_U32(&mcPwmInput.pwm.PWMCompareAMP, &mcPwmInput.PWMARRUpdate);
 149   2             mcPwmInput.PWMDivFlag=0;
 150   2          }
 151   1          if( mcFocCtrl.ESDIVFlag==1)  //ÂêØÂä®Èô§Ê≥ïÂô®ÔºåÈÅøÂÖç‰∏éËøáË∞ÉÂÄº‰∏≠ÁöÑÈô§Ê≥ïÂÜ≤Á™Å
 152   1          {
 153   2             mcFocCtrl.SQUSpeedDIVEs = MDU_DIV_XDATA_U32(&mcFocCtrl.SQUSysSpeed,&mcFocCtrl.EsValue);
 154   2             mcFocCtrl.ESDIVFlag=0;
 155   2          }
 156   1      }
 157          /*---------------------------------------------------------------------------*/
 158          /* Name   : void PWMInputCapture(void)
 159          /* Input  : NO
 160          /* Output : NO
 161          /* Description: ËæìÂÖ•PWMÂ§ÑÁêÜ
 162          /*---------------------------------------------------------------------------*/
 163          void PWMInputCapture(void)
 164          {
 165   1        uint16 MotorControlVSP;
 166   1      
 167   1         if(mcPwmInput.PWMUpdateFlag==1)  // ÊúâÊñ∞ÁöÑdutyÊõ¥Êñ∞
 168   1         {
 169   2            if((Abs_F32(mcPwmInput.PWMCompare-mcPwmInput.PWMCompareOld)<50)// ‰∏§Ê¨°ÊØîËæÉÂÄºÁõ∏ËøëÔºåÂáèÂ∞ëËØªÈ
             -îôÁéá
 170   2              &&(Abs_F32(mcPwmInput.PWMARROld-mcPwmInput.PWMARR)<50)// ‰∏§Ê¨°Âë®ÊúüÂÄºÁõ∏ËøëÔºåÂáèÂ∞ëËØªÈîôÁéá
 171   2      //        &&((100<mcPwmInput.PWMARR)&&(mcPwmInput.PWMARR<6000))// Âë®ÊúüÂÄºÂú®‰∏ÄÂÆöËåÉÂõ¥ÂÜÖÊâçËÆ§‰∏∫ÊúâÊ
             -ïàÔºåÂç≥‰∏ÄÂÆöÈ¢ëÁéáËåÉÂõ¥
 172   2              &&(mcPwmInput.PWMDivFlag==0))
 173   2              {
 174   3                mcPwmInput.PWMFlag=1;                               // PWMFlagÁΩÆ1ÊúüÈó¥Ôºå‰∏çËØªÂèñTIM3__DRÂíåT
             -IM3__ARR;ÔºåÈò≤Ê≠¢Âá∫Èîô
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 4   

 175   3                mcPwmInput.pwm.PWMCompareUpdate[0]=(mcPwmInput.PWMCompare>>1);// ÂØπÂÖ∂‰πò‰ª•32768
 176   3                mcPwmInput.PWMARRUpdate=mcPwmInput.PWMARR;
 177   3                mcPwmInput.PWMDivFlag=1;                            // ÂêØÂä®Èô§Ê≥ï
 178   3                mcPwmInput.PWMFlag=0;
 179   3              }
 180   2             if(mcPwmInput.PWMDivFlag==0)
 181   2              {
 182   3                if(mcPwmInput.PWMcnt<3)//2Ê¨°Ê±ÇÂπ≥ÂùáÂÄº
 183   3                {
 184   4                  mcPwmInput.PWMcnt++;
 185   4                  mcPwmInput.PWMVSum +=mcPwmInput.PWMDuty;
 186   4                }
 187   3                else
 188   3                {
 189   4                  MotorControlVSP= (mcPwmInput.PWMVSum >>1);//Ê≥®ÊÑèÂÖ∂Êúâ‰∏Ä‰∏™Âè≥Áßª‰∏éÂâçÈù¢ÁöÑÊØîËæÉÂÄºÊ†áÂπ
             -∫ÂåñÊúâÂÖ≥
 190   4                  mcPwmInput.PWMVSum=0;
 191   4                  mcPwmInput.PWMcnt =0;
 192   4                }
 193   3                 MotorControlVSP=mcPwmInput.PWMDuty;
 194   3               if((MotorControlVSP > ONPWMDuty)&&(MotorControlVSP <=(OFFPWMDutyHigh+1)))
 195   3                {
 196   4                  mcSpeedRamp.FlagONOFF = 1;
 197   4                }
 198   3               else if(MotorControlVSP < OFFPWMDuty)//||(MotorControlVSP >= OFFPWMDutyHigh))
 199   3                {
 200   4                  mcSpeedRamp.FlagONOFF = 0;
 201   4                }
 202   3      
 203   3                //ËΩ¨ÈÄüÊõ≤Á∫øËÆ°ÁÆó
 204   3                if(mcSpeedRamp.FlagONOFF==1)
 205   3                {
 206   4                  if(MotorControlVSP <= MINPWMDuty)
 207   4                  {
 208   5                    mcSpeedRamp.TargetValue = Motor_Min_Speed;
 209   5                  }
 210   4                  else if(MotorControlVSP < MAXPWMDuty)
 211   4                  {
 212   5                    mcSpeedRamp.TargetValue = Motor_Min_Speed + SPEED_K*(MotorControlVSP-MINPWMDuty);
 213   5                  }
 214   4                  else
 215   4                  {
 216   5                    mcSpeedRamp.TargetValue = Motor_Max_Speed;
 217   5                  }
 218   4                }
 219   3                else
 220   3                {
 221   4                  mcSpeedRamp.TargetValue =0;
 222   4                }
 223   3              }
 224   2      
 225   2            mcPwmInput.PWMUpdateFlag =0;
 226   2            mcPwmInput.PWMCompareOld=mcPwmInput.PWMCompare;//Â∞ÜÊ≠§Ê¨°ÊØîËæÉÂÄºËµãÂÄºÁªô‰∏äÊ¨°ÊØîËæÉÂÄº
 227   2            mcPwmInput.PWMARROld=mcPwmInput.PWMARR;//Â∞ÜÊ≠§Ê¨°Âë®ÊúüÂÄºËµãÂÄºÁªô‰∏äÊ¨°Âë®ÊúüÂÄº
 228   2          }
 229   1      }
 230          /*****************************************************************************
 231           * Function:     void Fault_OverVoltage(mcFaultVarible *h_Fault)
 232           * Description:  ËøáÂéãÊ¨†Âéã‰øùÊä§ÂáΩÊï∞ÔºöÁ®ãÂ∫èÊØè5msÂà§Êñ≠‰∏ÄÊ¨°ÔºåÊØçÁ∫øÁîµÂéãÂ§ß‰∫éËøáÂéã‰øùÊä§ÂÄºÊó
             -∂ÔºåËÆ°Êï∞Âô®Âä†‰∏ÄÔºåËÆ°Êï∞Âô®ÂÄºË∂ÖËøá20Ê¨°ÔºåÂà§Êñ≠‰∏∫ËøáÂéã‰øùÊä§ÔºåÂÖ≥Èó≠ËæìÂá∫;Âèç‰πãÔºåËÆ°Êï∞Âô®ÊÖ¢ÊÖ¢Âáè
 233                           ÂêåÁêÜÔºåÊ¨†Âéã‰øùÊä§„ÄÇ
 234                           ÁîµÊú∫ËøáÊ¨†Âéã‰øùÊä§Áä∂ÊÄÅ‰∏ãÔºåÊØçÁ∫øÁîµÂéãÊÅ¢Â§çÂà∞Ê¨†ÂéãÊÅ¢Â§çÂÄº‰ª•‰∏äÔºåËøáÂéãÊÅ¢Â§ç
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 5   

             -ÂÄº‰ª•‰∏ãÊó∂ÔºåËÆ°Êï∞Âô®Âä†‰∏ÄÔºåË∂ÖËøá200Ê¨°ÂêéÔºåÊÅ¢Â§ç„ÄÇÊ†πÊçÆÊ°£‰Ωç‰ø°ÊÅØÊù•ÂÜ≥ÂÆöÊÅ¢Â§çÂà∞Âì™‰∏™Áä∂ÊÄÅ„ÄÇ
 235           * Parameter:    mcFaultVarible *h_Fault
 236           * Return:       no
 237           *****************************************************************************/
 238          void Fault_OverUnderVoltage(FaultVarible *h_Fault)
 239          {
 240   1        //ËøáÂéã‰øùÊä§
 241   1          if(mcFaultSource == FaultNoSource)//Á®ãÂ∫èÊó†ÂÖ∂‰ªñ‰øùÊä§‰∏ã
 242   1          {
 243   2              if(mcFocCtrl.mcDcbusFlt > OVER_PROTECT_VALUE)  //ÊØçÁ∫øÁîµÂéãÂ§ß‰∫éËøáÂéã‰øùÊä§ÂÄºÊó∂ÔºåËÆ°Êï∞ÔºåË∂ÖËø
             -á20Ê¨°ÔºåÂà§Êñ≠‰∏∫ËøáÂéã‰øùÊä§ÔºåÂÖ≥Èó≠ËæìÂá∫;Âèç‰πãÔºåËÆ°Êï∞Âô®ÊÖ¢ÊÖ¢Âáè
 244   2              {
 245   3                h_Fault->OverVoltDetecCnt++;
 246   3                if(h_Fault->OverVoltDetecCnt > 20)//Ê£ÄÊµã100ms
 247   3                {
 248   4                  h_Fault->OverVoltDetecCnt = 0;
 249   4                  mcFaultSource=FaultOverVoltage;
 250   4                  FaultProcess();
 251   4                }
 252   3              }
 253   2              else
 254   2              {
 255   3                if(h_Fault->OverVoltDetecCnt>0)
 256   3                {
 257   4                  h_Fault->OverVoltDetecCnt--;
 258   4                }
 259   3              }
 260   2      
 261   2              //‰ΩéÁîµÂÖ≥Èó≠LED
 262   2              
 263   2              if(mcFocCtrl.mcDcbusFlt < CLOSE_LED_VALUE)
 264   2              {
 265   3                  h_Fault->CloseLedCnt++;
 266   3                  if(h_Fault->CloseLedCnt > 30)
 267   3                  {
 268   4                      h_Fault->CloseLedCnt = 0;
 269   4                      D1 = 1; D2 = 1; D3 = 1; D4 = 1;  D5 = 1; D6 = 1;
 270   4                      low_flag = 1;
 271   4                  }
 272   3              }
 273   2              else
 274   2              {
 275   3                  if(h_Fault->CloseLedCnt > 0)
 276   3                  {
 277   4                      h_Fault->CloseLedCnt--;
 278   4                  }
 279   3                  else
 280   3                  {
 281   4                      if(low_flag)
 282   4                      {
 283   5                        low_flag = 0;
 284   5                        KS.ChangeKeyFlg = 1;
 285   5                      }
 286   4                  }
 287   3              } 
 288   2              
 289   2              
 290   2            //Ê¨†Âéã‰øùÊä§
 291   2              if(mcFocCtrl.mcDcbusFlt< UNDER_PROTECT_VALUE)
 292   2              {
 293   3                h_Fault->UnderVoltDetecCnt++;
 294   3      
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 6   

 295   3                if(h_Fault->UnderVoltDetecCnt > 30)//Ê£ÄÊµã100ms
 296   3                {
 297   4                  h_Fault->UnderVoltDetecCnt = 0;
 298   4                  h_Fault->VoltDetecBraketCount = 120;
 299   4                  mcFaultSource=FaultUnderVoltage;
 300   4                  FaultProcess();
 301   4      
 302   4                  Flag_Key1Value = 0;
 303   4                  Flag_Key2Value = 0;
 304   4                  
 305   4                  if(KS.FlashWriteOnetimes == 0)
 306   4                  {
 307   5                              
 308   5                    Rom.WriteValue = KS.KeyValuetotal;   //Ê°£‰ΩçÂ≠òÂÇ®
 309   5                    Rom.ReadValue = Flash_GetAddress();     //ËØª
 310   5                    if((Rom.ReadValue == 0x11)||(Rom.ReadValue == 0x21) ||(Rom.ReadValue == 0x41) ||(Rom.ReadValue == 0
             -x12) ||(Rom.ReadValue == 0x22)
 311   5                    ||(Rom.ReadValue == 0x42)||(Rom.ReadValue == 0x14)||(Rom.ReadValue== 0x24)||(Rom.ReadValue == 0x44)
             -||(Rom.ReadValue == 0x18)
 312   5                    ||(Rom.ReadValue == 0x28)||(Rom.ReadValue == 0x48))
 313   5                    {
 314   6                      EA = 0;
 315   6                      Flash_ErasePageRom();                  //Êì¶
 316   6                      Flash_KeyWriteValue((Rom.WriteValue));  //ÂÜô 
 317   6                      EA = 1;
 318   6                      KS.FlashWriteOnetimes = 1;
 319   6                    }
 320   5      //              else
 321   5      //              {
 322   5      //                Flash_ErasePageRom();                  //Êì¶
 323   5      //                Flash_KeyWriteValue((0x21));  //ÂÜô 
 324   5      //                EA = 1;
 325   5      //              }
 326   5                  }
 327   4                }
 328   3              }
 329   2              else
 330   2              {
 331   3                if(h_Fault->UnderVoltDetecCnt>0)
 332   3                {
 333   4                  h_Fault->UnderVoltDetecCnt--;
 334   4                }
 335   3              }
 336   2          }
 337   1          if(((mcFaultSource==FaultOverVoltage)||(mcFaultSource==FaultUnderVoltage))&&(h_Fault->VoltDetecBraketCou
             -nt >0))
 338   1          {  
 339   2            h_Fault->VoltDetecBraketCount--;
 340   2            if((h_Fault->VoltDetecBraketCount >= 60))
 341   2            {
 342   3                DRV_DR = 0.1*DRV_ARR;                   //‰∏ãÊ°•ËáÇ10% duty
 343   3                ClrBit(DRV_CR, OCS);                    //OCS = 0, PWMÊù•Ê∫êDRV_COMR
 344   3                DRV_CMR |= 0x03;                         // UVWÁõ∏‰∏ãÊ°•ËæìÂá∫
 345   3                SetBit(DRV_CR, DRVEN);                    /*DRVËÆ°Êï∞Âô®‰ΩøËÉΩÔºå0-Á¶ÅÊ≠¢Ôºå1-‰ΩøËÉΩ*/
 346   3                MOE = 1;  
 347   3      
 348   3            }
 349   2            else if((h_Fault->VoltDetecBraketCount <= 40))
 350   2            {
 351   3              MOE = 0;
 352   3              DRV_OUT = 0x00;
 353   3              //D1 = 1; D2 = 1; D3 = 1; D4 = 1;  D5 = 1; D6 = 1;        
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 7   

 354   3            }
 355   2            else
 356   2            {
 357   3              h_Fault->VoltDetecBraketCount = 60;
 358   3            }
 359   2            
 360   2      //      if(h_Fault->mcVoltDetecBraketCount == 1)
 361   2      //      {
 362   2      //        FaultProcess();
 363   2      //      }
 364   2          }
 365   1      
 366   1          /*******ËøáÂéãÊ¨†Âéã‰øùÊä§ÊÅ¢Â§ç*********/
 367   1          if((mcState == mcFault) &&((mcFaultSource==FaultUnderVoltage)||(mcFaultSource==FaultOverVoltage)))
 368   1          {
 369   2      //      if((mcFocCtrl.mcDcbusFlt< OVER_RECOVER_VALUE)&&(mcFocCtrl.mcDcbusFlt> UNDER_RECOVER_VALUE))
 370   2      //      {
 371   2      //        h_Fault->VoltRecoverCnt++;
 372   2      //        if(h_Fault->VoltRecoverCnt>200)//ËøûÁª≠Ê£ÄÊµã1sÔºåËã•Ê≠£Â∏∏ÂàôÊÅ¢Â§ç
 373   2      //        {
 374   2      //          mcState = mcReady;
 375   2      //          mcFaultSource=FaultNoSource;
 376   2      //          h_Fault->VoltRecoverCnt = 0;
 377   2      //        }
 378   2      //      }
 379   2      //      else
 380   2      //      {
 381   2      //        h_Fault->VoltRecoverCnt = 0;
 382   2      //      }
 383   2         }
 384   1      }
 385          
 386          
 387          /*****************************************************************************
 388           * Function:     void Fault_Power(mcFaultVarible *h_Fault)
 389           * Description:  ÂäüÁéá‰øùÊä§ÂáΩÊï∞
 390           * Parameter:    mcFaultVarible *h_Fault
 391           * Return:       no
 392           *****************************************************************************/
 393          void Fault_Power(FaultVarible *h_Fault)
 394          {
 395   1      
 396   1          if(mcFaultSource == FaultNoSource)//Á®ãÂ∫èÊó†ÂÖ∂‰ªñ‰øùÊä§‰∏ã
 397   1          {
 398   2              if(mcFocCtrl.Powerlpf > PowerLimit)  //ÂäüÁéáÂ§ß‰∫é‰øùÊä§ÂÄºÊó∂ËÆ°Êï∞ÔºåË∂ÖËøá20Ê¨°ÔºåÂà§Êñ≠‰∏∫ËøáËΩΩ‰
             -øùÊä§ÔºåÂÖ≥Èó≠ËæìÂá∫;Âèç‰πãÔºåËÆ°Êï∞Âô®ÊÖ¢ÊÖ¢Âáè
 399   2              {
 400   3                h_Fault->OverPowerDetecCnt++;
 401   3                if(h_Fault->OverPowerDetecCnt > 20)
 402   3                {
 403   4                  h_Fault->OverPowerDetecCnt = 0;
 404   4                  mcFaultSource=FaultOverPower;
 405   4                  FaultProcess();
 406   4                }
 407   3              }
 408   2              else
 409   2              {
 410   3                if(h_Fault->OverPowerDetecCnt>0)
 411   3                {
 412   4                  h_Fault->OverPowerDetecCnt--;
 413   4                }
 414   3              }
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 8   

 415   2          }
 416   1      
 417   1        }
 418          
 419          
 420          /*****************************************************************************
 421           * Function:     void Fault_Overcurrent(CurrentVarible *h_Cur)
 422           * Description:  ÁîµÊú∫ËøêË°åÊàñËÄÖÂêØÂä®Êó∂ÔºåÂΩì‰∏âÁõ∏‰∏≠Êüê‰∏ÄÁõ∏ÊúÄÂ§ßÂÄºÂ§ß‰∫éOverCurrentValueÔºåÂàôO
             -verCurCntÂä†1„ÄÇ
 423                           ËøûÁª≠Á¥ØÂä†3Ê¨°ÔºåÂà§Êñ≠‰∏∫ËΩØ‰ª∂ËøáÊµÅ‰øùÊä§„ÄÇÊâßË°åÊó∂Èó¥Á∫¶30.4us„ÄÇ
 424           * Parameter:    mcFaultVarible *h_Fault
 425           * Return:       no
 426           *****************************************************************************/
 427          void Fault_Overcurrent(CurrentVarible *h_Cur)
 428          {
 429   1        if((mcState == mcRun)||(mcState == mcStart))            // check over current in rum and open mode
 430   1        {
 431   2      
 432   2          h_Cur->Abs_ia = Abs_F16(FOC__IA);
 433   2          h_Cur->Abs_ib = Abs_F16(FOC__IB);
 434   2          h_Cur->Abs_ic = Abs_F16(FOC__IC);
 435   2          if(h_Cur->Abs_ia> h_Cur->Max_ia)                      // Ê≠§ÈÉ®ÂàÜÊó¢Áî®‰∫éËΩØ‰ª∂ËøáÊµÅ‰øùÊä§ÔºåÂèàÁî®‰∫
             -éÁº∫Áõ∏‰øùÊä§
 436   2          {
 437   3             h_Cur->Max_ia = h_Cur->Abs_ia;
 438   3          }
 439   2          if(h_Cur->Abs_ib > h_Cur->Max_ib)
 440   2          {
 441   3             h_Cur->Max_ib = h_Cur->Abs_ib;
 442   3          }
 443   2          if(h_Cur->Abs_ic > h_Cur->Max_ic)
 444   2          {
 445   3             h_Cur->Max_ic = h_Cur->Abs_ic;
 446   3          }
 447   2      
 448   2          if((h_Cur->Max_ia>=OverSoftCurrentValue)||(h_Cur->Max_ib>=OverSoftCurrentValue)||(h_Cur->Max_ic>=OverSof
             -tCurrentValue))
 449   2          {
 450   3            h_Cur->OverCurCnt++;
 451   3            if(h_Cur->OverCurCnt>=3)
 452   3            {
 453   4              GP36=~GP36;
 454   4              h_Cur->Max_ia=0;
 455   4              h_Cur->Max_ib=0;
 456   4              h_Cur->Max_ic=0;
 457   4              h_Cur->OverCurCnt=0;
 458   4              mcFaultSource=FaultSoftOVCurrent;
 459   4              FaultProcess();
 460   4            }
 461   3          }
 462   2          else
 463   2          {
 464   3            if(h_Cur->OverCurCnt>0)
 465   3            {
 466   4              h_Cur->OverCurCnt--;
 467   4            }
 468   3          }
 469   2        }
 470   1      }
 471          
 472          
 473          /*****************************************************************************
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 9   

 474           * Function:     void Fault_OverCurrentRecover(mcFaultVarible *h_Fault)
 475           * Description:  ËΩØÁ°¨‰ª∂ËøáÊµÅ‰øùÊä§ÊÅ¢Â§ç
 476           * Parameter:    mcFaultVarible *h_Fault
 477           * Return:       no
 478           *****************************************************************************/
 479          void Fault_OverCurrentRecover(FaultVarible *h_Fault)
 480          {
 481   1        if((mcState == mcFault)&&((mcFaultSource==FaultSoftOVCurrent)||(mcFaultSource==FaultHardOVCurrent))&&(mcP
             -rotectTime.CurrentPretectTimes<5))
 482   1        {
 483   2          h_Fault->CurrentRecoverCnt++;
 484   2          if(h_Fault->CurrentRecoverCnt>=OverCurrentRecoverTime)//1000*5=5s
 485   2          {
 486   3            h_Fault->CurrentRecoverCnt=0;
 487   3            mcProtectTime.CurrentPretectTimes++;
 488   3            mcState = mcReady;
 489   3            mcFaultSource=FaultNoSource;
 490   3          }
 491   2        }
 492   1      }
 493          
 494          /*****************************************************************************
 495           * Function:     void Fault_OverPowerRecover(mcFaultVarible *h_Fault)
 496           * Description:  ÂäüÁéá‰øùÊä§ÊÅ¢Â§çÂáΩÊï∞
 497           * Parameter:    mcFaultVarible *h_Fault
 498           * Return:       no
 499           *****************************************************************************/
 500          void Fault_OverPowerRecover(FaultVarible *h_Fault)
 501          {
 502   1        if((mcState == mcFault)&&(mcFaultSource==FaultOverPower)&&(mcProtectTime.PowerPretectTimes<5))
 503   1        {
 504   2          h_Fault->OverPowerDetecCnt++;
 505   2          if(h_Fault->OverPowerDetecCnt>=OverPowerRecoverTime)
 506   2          {
 507   3            h_Fault->OverPowerDetecCnt=0;
 508   3            mcProtectTime.PowerPretectTimes++;
 509   3            mcState = mcReady;
 510   3            mcFaultSource=FaultNoSource;
 511   3          }
 512   2        }
 513   1      }
 514          
 515          
 516          
 517          /*****************************************************************************
 518           * Function:     void Fault_Start(mcFaultVarible *h_Fault)
 519           * Description:  ÂêØÂä®‰øùÊä§ÂáΩÊï∞ÔºåÁîµÊú∫ËøêË°åÁä∂ÊÄÅ‰∏ãÔºåÁîµÊú∫Âú®Ââç5s‰º∞ÁÆóËΩ¨ÈÄüËææÂà∞Â†µËΩ¨‰øùÊä§
             -ÂÄºÊàñËÄÖ5sÂêéÂèçÁîµÂä®ÂäøÂÄºÂ§™‰Ωé(Ê≠§ÊñπÊ≥ïÊú™È™åËØÅ)
 520                            Êàñ4sÂÜÖËøòÂú®CtrlModeÁä∂ÊÄÅÔºåÂç≥ÈÄüÂ∫¶‰Ωé‰∫éMOTOR_LOOP_RPMÔºåÁ®ãÂ∫èÂà§Êñ≠‰∏∫ÂêØÂä®Â§±Ë
             -¥•ÔºåÁîµÊú∫ÂÅúÊú∫„ÄÇ
 521                            ÂΩìÁ®ãÂ∫èÂà§Êñ≠‰∏∫ÂêØÂä®Â§±Ë¥•ÂêéÔºåËã•ÈáçÂêØÊ¨°Êï∞Â∞ë‰∫éÊàñÁ≠â‰∫é5Ê¨°ÔºåÁ®ãÂ∫èÁ´ãÂç≥Ëøõ
             -ÂÖ•Ê†°ÂáÜÁä∂ÊÄÅÔºåÁ≠âÂæÖÈáçÂêØ„ÄÇ
 522           * Parameter:    mcFaultVarible *h_Fault
 523           * Return:       no
 524           *****************************************************************************/
 525            void Fault_Start(FaultVarible *h_Fault)
 526            {
 527   1          /*******ÂêØÂä®‰øùÊä§ÊÅ¢Â§ç*********/
 528   1      //    h_Fault->mcEsValue = FOC__ESQU;
 529   1      
 530   1          if(mcState == mcRun)
 531   1          {
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 10  

 532   2            //ÊñπÊ≥ï‰∏ÄÔºå5sÂÜÖÈÄüÂ∫¶Â§ß‰∫éÊúÄÂ§ßÈÄüÂ∫¶ÔºåÂêåÊó∂ÂèçÁîµÂä®ÂäøÂÄº‰Ωé‰∫é‰∏ÄÂÆöÂÄº
 533   2            if(h_Fault->StartSpeedCnt<=1000)
 534   2            {
 535   3              h_Fault->StartSpeedCnt++;
 536   3              if((mcFocCtrl.SpeedFlt > Motor_Max_Speed)&&(mcFocCtrl.EsValue<50))
 537   3              {
 538   4                h_Fault->StartSpeedCnt = 0;
 539   4                mcFaultSource=FaultStart;
 540   4                FaultProcess();
 541   4                mcProtectTime.SecondStartTimes++;
 542   4                mcProtectTime.StartFlag  =  1;
 543   4              }
 544   3            }
 545   2           //ÊñπÊ≥ï‰∫å
 546   2            if(h_Fault->StartEsCnt<=1200)//Ââç6sÔºåÁ≠âÂæÖ1.5sÂêéÔºåÂºÄÂßãÂà§Êñ≠EsÔºåÂ¶ÇÊûúË∂ÖËøá‰∏ÄÂÆöÊ¨°Êï∞ÔºåÂàôÂ
             -§±Ë¥•
 547   2            {
 548   3              h_Fault->StartEsCnt++;
 549   3              h_Fault->StartDelay++;
 550   3              if(h_Fault->StartDelay>=300)        // 1.5s
 551   3              {
 552   4                 h_Fault->StartDelay=300;
 553   4                 if((mcFocCtrl.EsValue <20))//&&(mcFocCtrl.CtrlMode==0))
 554   4                  {
 555   5                    h_Fault->StartESCount++;
 556   5                    if(h_Fault->StartESCount>=50)     //50Ê¨°EsÂ∞è‰∫éËÆæÂÆöÂÄºÔºåÂêØÂä®Â§±Ë¥•
 557   5                    {
 558   6                      mcFaultSource=FaultStart;
 559   6                      FaultProcess();
 560   6                      mcProtectTime.SecondStartTimes++;
 561   6                      h_Fault->StartDelay=0;
 562   6                      h_Fault->StartESCount=0;
 563   6                      mcProtectTime.StartFlag  =  2;
 564   6                    }
 565   5                  }
 566   4                  else
 567   4                  {
 568   5                    if(h_Fault->StartESCount>0)
 569   5                      h_Fault->StartESCount--;
 570   5                  }
 571   4             }
 572   3           }
 573   2           else
 574   2           {
 575   3             h_Fault->StartESCount=0;
 576   3           }
 577   2           
 578   2           
 579   2            //ÊñπÊ≥ï‰∏âÔºåÈïøÊó∂Èó¥Âú®CtrlMode=0Áä∂ÊÄÅ
 580   2            if(mcFocCtrl.CtrlMode==0)         
 581   2            {
 582   3              h_Fault->StartFocmode++;
 583   3              if(h_Fault->StartFocmode>=8000)   //Âú®MODE0Ê®°ÂºèË∂ÖËøá8sËµ∑Âä®Â§±Ë¥•
 584   3              {
 585   4                h_Fault->StartFocmode=0;
 586   4                mcFaultSource=FaultStart;
 587   4                FaultProcess();
 588   4                mcProtectTime.SecondStartTimes++;
 589   4                mcProtectTime.StartFlag  =  3;
 590   4              }
 591   3            }
 592   2            
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 11  

 593   2          }
 594   1          
 595   1          //Ëµ∑Âä®‰øùÊä§ÊÅ¢Â§ç
 596   1       #if (!StartONOFF_Enable)    //Ëµ∑ÂÅúÊµãËØïÊó∂Â±èËîΩËµ∑Âä®‰øùÊä§ÊÅ¢Â§ç
 597   1          {
 598   2           if((mcFaultSource==FaultStart)&&(mcState == mcFault)&&(mcProtectTime.SecondStartTimes<=StartProtectRest
             -artTimes))
 599   2           {
 600   3             
 601   3             h_Fault->StartRecoverDelayCnt++;
 602   3             if(h_Fault->StartRecoverDelayCnt > StartRecoverDelayTimes)   //ÂêØÂä®‰øùÊä§Âª∂Êó∂ÊÅ¢Â§çÊó∂Èó¥
 603   3             {
 604   4                h_Fault->StartRecoverDelayCnt = 0;
 605   4                mcFaultSource=FaultNoSource;
 606   4                mcState = mcInit;
 607   4             }
 608   3           }
 609   2          }
 610   1        #endif
 611   1          
 612   1        }
 613          
 614           
 615          
 616          
 617           /*****************************************************************************
 618           * Function:     void Fault_Stall(mcFaultVarible *h_Fault)
 619           * Description:  Â†µËΩ¨‰øùÊä§ÂáΩÊï∞ÔºåÊúâ‰∏âÁßç‰øùÊä§ÊñπÂºèÔºå
 620                           Á¨¨‰∏ÄÁßçÔºå
 621                           Á¨¨‰∫åÁßçÔºåÁîµÊú∫ËøêË°åÁä∂ÊÄÅ‰∏ãÔºåÂª∂Ëøü4sÂà§Êñ≠Ôºå‰º∞ÁÆóÈÄüÂ∫¶ÁªùÂØπÂÄºË∂ÖËøáÂ†µËΩ¨ÈÄüÂ
             -∫¶ËøûÁª≠5Ê¨°Ôºõ
 622                           Á¨¨‰∏âÁßçÔºåÁîµÊú∫ËøêË°åÁä∂ÊÄÅ‰∏ãÔºåÂΩìU,V‰∏§Áõ∏ÁîµÊµÅÁªùÂØπÂÄºÂ§ß‰∫éÂ†µËΩ¨ÁîµÊµÅ‰øùÊä§ÂÄº
             -ËøûÁª≠6Ê¨°Ôºõ
 623                           ÂΩì‰ª•‰∏ä‰∏âÁßçÁöÑ‰ªª‰Ωï‰∏ÄÁßç‰øùÊä§Ëß¶ÂèëÊó∂ÔºåÁîµÊú∫ÂÅúÊú∫ÔºåÁ®ãÂ∫èÂà§Êñ≠‰∏∫Â†µËΩ¨‰øùÊä§
             -Ôºõ
 624                           ÂΩìÂ†µËΩ¨‰øùÊä§Áä∂ÊÄÅ‰∏ãÔºåUÁõ∏ÈááÈõÜÂÄº‰Ωé‰∫éÂ†µËΩ¨ÊÅ¢Â§çÂÄºÊó∂ÔºåËã•Â†µËΩ¨Ê¨°Êï∞Â∞è‰∫éÊà
             -ñÁ≠â‰∫éÂ†µËΩ¨ÈáçÂêØÊ¨°Êï∞8Ê¨°Ôºå
 625                           Á®ãÂ∫èÂª∂ËøümcStallRecoverÈáçÊñ∞ÂêØÂä®ÔºåËøõË°åÊ†°ÂáÜÁä∂ÊÄÅ„ÄÇ
 626           * Parameter:    mcFaultVarible *h_Fault
 627           * Return:       no
 628           *****************************************************************************/
 629          //Â†µËΩ¨‰øùÊä§
 630          void Fault_Stall(FaultVarible *h_Fault,CurrentVarible *h_Cur)
 631          {
 632   1      //  h_Fault->mcEsValue = FOC__ESQU;
 633   1        if(mcState == mcRun)
 634   1        {
 635   2          if(h_Fault->StallDelayCnt <=1000)// ÂêØÂä®ÂêéÂª∂Êó∂5sÂà§Êñ≠ÊòØÂê¶Â†µËΩ¨‰øùÊä§
 636   2          {
 637   3            h_Fault->StallDelayCnt ++;
 638   3          }
 639   2          else
 640   2          {
 641   3            //method 1ÔºåÂΩìÂèçÁîµÂä®ÂäøÂ§™Â∞è ÊàñÂΩì ËΩ¨ÈÄüÂ§™Â§ß‰ΩÜÂèçÁîµÂä®ÂäøÂç¥ÂæàÂ∞èÊó∂ËøõÂÖ•‰øùÊä§
 642   3            if((&mcFocCtrl.EsValue< 20)||((FOC__EOME > _Q15(1200.0/MOTOR_SPEED_BASE))&&(mcFocCtrl.EsValue< 50)))
 643   3            {
 644   4              h_Fault->StallDectEs++;
 645   4              if(h_Fault->StallDectEs >= 50)   //Âà§Êñ≠Êª°Ë∂≥Êù°‰ª∂ËææÂà∞ËÆæÁΩÆÊ¨°Êï∞Ôºå‰øùÊä§Âä®‰Ωú
 646   4              {
 647   5                h_Fault->StallDectEs=0;
 648   5                mcFaultSource=FaultStall;
 649   5                mcProtectTime.StallTimes++;        //Â†µËΩ¨Ê¨°Êï∞+1
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 12  

 650   5                FaultProcess();
 651   5                h_Fault->StallDelayCnt = 0;        //‰øùÊä§ÂêéÈáçÂêØÂºÄÂßãÈáçÊñ∞ËÆ°Êï∞Ôºå‰øùÊåÅ5SÂª∂Ëøü
 652   5                mcProtectTime.StallFlag  =  1;
 653   5              }
 654   4            }
 655   3            else
 656   3            {
 657   4              if( h_Fault->StallDectEs>0)
 658   4                h_Fault->StallDectEs--;
 659   4            }
 660   3            
 661   3            //method 2ÔºåÂà§Êñ≠ÈÄüÂ∫¶‰Ωé‰∫éÂ†µËΩ¨ÊúÄÂ∞èÂÄºÊàñËÄÖË∂ÖËøáÂ†µËΩ¨ÊúÄÂ§ßÂÄº
 662   3            if((mcFocCtrl.SpeedFlt<Motor_Stall_Min_Speed)||(mcFocCtrl.SpeedFlt > Motor_Stall_Max_Speed))
 663   3            {
 664   4              h_Fault->StallDectSpeed++;
 665   4              if(h_Fault->StallDectSpeed >= 20)   //Âà§Êñ≠Êª°Ë∂≥Êù°‰ª∂ËææÂà∞ËÆæÁΩÆÊ¨°Êï∞Ôºå‰øùÊä§Âä®‰Ωú
 666   4              {
 667   5                h_Fault->StallDectSpeed=0;
 668   5                mcFaultSource=FaultStall;
 669   5                mcProtectTime.StallTimes++;       //Â†µËΩ¨Ê¨°Êï∞+1
 670   5                FaultProcess();
 671   5                h_Fault->StallDelayCnt = 0;       //‰øùÊä§ÂêéÈáçÂêØÂºÄÂßãÈáçÊñ∞ËÆ°Êï∞Ôºå‰øùÊåÅ5SÂª∂Ëøü
 672   5                mcProtectTime.StallFlag =2;
 673   5              }
 674   4            }
 675   3            else
 676   3            {
 677   4              if(h_Fault->StallDectSpeed>0)
 678   4              h_Fault->StallDectSpeed--;
 679   4            }
 680   3            
 681   3            //method 3      A/B/C‰∏âÁõ∏‰ªªÊÑè‰∏ÄÁõ∏Áõ∏ÁîµÊµÅÂ§ß‰∫éÂ†µËΩ¨ÁîµÊµÅÔºåÂ†µËΩ¨‰øùÊä§
 682   3          if((h_Cur->Max_ia >= StallCurrentValue)||
 683   3             (h_Cur->Max_ib >= StallCurrentValue)||
 684   3             (h_Cur->Max_ic >= StallCurrentValue))
 685   3          {      
 686   4            h_Fault->mcStallDeCurrent++;              
 687   4            if(h_Fault->mcStallDeCurrent >= 20)         //Âà§Êñ≠Êª°Ë∂≥Êù°‰ª∂ËææÂà∞ËÆæÁΩÆÊ¨°Êï∞Ôºå‰øùÊä§Âä®‰Ωú
 688   4            {
 689   5              h_Fault->mcStallDeCurrent=0;
 690   5              mcFaultSource=FaultStall; 
 691   5              mcProtectTime.StallTimes++;
 692   5              FaultProcess();   
 693   5              h_Fault->StallDelayCnt = 0;       //‰øùÊä§ÂêéÈáçÂêØÂºÄÂßãÈáçÊñ∞ËÆ°Êï∞Ôºå‰øùÊåÅ5SÂª∂Ëøü
 694   5              mcProtectTime.StallFlag  =  3;
 695   5            }            
 696   4          } 
 697   3          else
 698   3            {
 699   4              if(h_Fault->mcStallDeCurrent>0)
 700   4              h_Fault->mcStallDeCurrent--;
 701   4            }
 702   3        }
 703   2      }
 704   1         
 705   1       #if (!StartONOFF_Enable)
 706   1      {
 707   2           /*******Â†µËΩ¨‰øùÊä§ÊÅ¢Â§ç*********/
 708   2              if((mcFaultSource==FaultStall)&&(mcState == mcFault)&&(mcProtectTime.StallTimes<=4))  //Â†µËΩ¨ÈáçÂ
             -êØÊ¨°Êï∞
 709   2              {
 710   3                h_Fault->StallReCount++;
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 13  

 711   3                if(h_Fault->StallReCount>=StallRecoverTime)
 712   3                {
 713   4                  h_Fault->StallReCount=0;        //16000
 714   4                  mcFaultSource=FaultNoSource;
 715   4                  mcState =   mcInit;
 716   4                }
 717   3              }
 718   2              else
 719   2              {
 720   3                h_Fault->StallReCount=0;
 721   3              }
 722   2      }
 723   1      #endif
 724   1          
 725   1      }
 726           /*****************************************************************************
 727           * Function:     void Fault_phaseloss(mcFaultVarible *h_Fault)
 728           * Description:  Áº∫Áõ∏‰øùÊä§ÂáΩÊï∞ÔºåÂΩìÁîµÊú∫ËøêË°åÁä∂ÊÄÅ‰∏ãÔºå10msÂèñ‰∏âÁõ∏ÁîµÊµÅÁöÑÊúÄÂ§ßÂÄºÔºå
 729                           1.5sÂà§Êñ≠ÂêÑÁõ∏ÁîµÊµÅÊúÄÂ§ßÂÄºÔºåËã•Â≠òÂú®‰∏§Áõ∏ÁîµÊµÅÂÄºÂ§ß‰∫é‰∏ÄÂÆöÂÄºÔºåËÄåÁ¨¨‰∏âÁõ∏Áî
             -µÊµÅÂÄºÂç¥ÈùûÂ∏∏Â∞èÔºåÂàôÂà§Êñ≠‰∏∫Áº∫Áõ∏‰øùÊä§ÔºåÁîµÊú∫ÂÅúÊú∫Ôºõ
 730           * Parameter:    mcFaultVarible *h_Fault
 731           * Return:       no
 732           *****************************************************************************/
 733            void Fault_phaseloss(FaultVarible *h_Fault)
 734            {   
 735   1            if(mcState == mcRun)
 736   1           {
 737   2              h_Fault->Lphasecnt++;
 738   2              if(h_Fault->Lphasecnt>50)//100*5=500ms  500msÂà§Êñ≠‰∏ÄÊ¨°
 739   2              {
 740   3                 h_Fault->Lphasecnt=0;
 741   3      
 742   3                 if(((mcCurVarible.Max_ia>(mcCurVarible.Max_ib*3))||(mcCurVarible.Max_ia>(mcCurVarible.Max_ic*3))) ||
             -(mcCurVarible.Max_ia>PhaseLossCurrentValue))
 743   3                 {
 744   4                    h_Fault->AOpencnt++;
 745   4                 }
 746   3                 else
 747   3                 {
 748   4                  if(h_Fault->AOpencnt>0)
 749   4                    h_Fault->AOpencnt --;
 750   4                 }
 751   3                 if(((mcCurVarible.Max_ib >(mcCurVarible.Max_ia*3))||(mcCurVarible.Max_ib >(mcCurVarible.Max_ic*3))) 
             -||(mcCurVarible.Max_ib >PhaseLossCurrentValue))
 752   3                 {
 753   4                   h_Fault->BOpencnt++;
 754   4                 }
 755   3                else
 756   3                 {
 757   4                   if(h_Fault->BOpencnt>0)
 758   4                    h_Fault->BOpencnt --;
 759   4                 }
 760   3                 if(((mcCurVarible.Max_ic >(mcCurVarible.Max_ia*3))||(mcCurVarible.Max_ic >(mcCurVarible.Max_ib*3))) 
             -||(mcCurVarible.Max_ic >PhaseLossCurrentValue))
 761   3                 {
 762   4                   h_Fault->COpencnt++;
 763   4                 }
 764   3                else
 765   3                 {
 766   4                   if(h_Fault->COpencnt>0)
 767   4                    h_Fault->COpencnt --;
 768   4                 }
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 14  

 769   3                  mcCurVarible.Max_ia = 0;
 770   3                  mcCurVarible.Max_ib = 0;
 771   3                  mcCurVarible.Max_ic = 0;
 772   3                if(h_Fault->AOpencnt > 20|| h_Fault->BOpencnt > 20 || h_Fault->COpencnt > 20)
 773   3                 {
 774   4                    mcProtectTime.LossPHTimes++;
 775   4                    mcFaultSource=FaultLossPhase;
 776   4                    FaultProcess();
 777   4                 }
 778   3              }
 779   2            }
 780   1      
 781   1           /*******Áº∫Áõ∏‰øùÊä§ÊÅ¢Â§ç*********/
 782   1      #if (!StartONOFF_Enable)           //Ëµ∑ÂÅúÊµãËØïÊó∂Â±èËîΩÁº∫Áõ∏‰øùÊä§ÊÅ¢Â§ç
 783   1      {
 784   2      //      if((mcFaultSource==FaultLossPhase)&&(mcState == mcFault)&&(mcProtectTime.LossPHTimes<5))//ÂèØÈáçÂê
             -Ø5Ê¨°
 785   2      //       {
 786   2      //           h_Fault->mcLossPHRecCount++;
 787   2      //           if(h_Fault->mcLossPHRecCount>=PhaseLossRecoverTime)
 788   2      //           {
 789   2      //             h_Fault->AOpencnt=0;
 790   2      //             h_Fault->BOpencnt=0;
 791   2      //             h_Fault->COpencnt=0;
 792   2      //             mcState = mcReady;
 793   2      //             mcFaultSource=FaultNoSource;
 794   2      //           }
 795   2      //       }
 796   2      //    else
 797   2      //       {
 798   2      //           h_Fault->mcLossPHRecCount=0;
 799   2      //       }
 800   2      }
 801   1      #endif
 802   1                 
 803   1          }
 804          
 805          
 806          extern uint8 test_flag;
 807          /*---------------------------------------------------------------------------*/
 808          /* Name   : void Fault_Detection(void)
 809          /* Input  : NO
 810          /* Output : NO
 811          /* Description: ‰øùÊä§ÂáΩÊï∞ÔºåÂõ†‰øùÊä§ÁöÑÊó∂Èó¥ÂìçÂ∫î‰∏ç‰ºöÂæàÈ´òÔºåÈááÁî®ÂàÜÊÆµÂ§ÑÁêÜÔºåÊØè5‰∏™ÂÆöÊó∂Âô
             -®‰∏≠Êñ≠ÊâßË°å‰∏ÄÊ¨°ÂØπÂ∫îÁöÑ‰øùÊä§
 812                          Â∏∏ËßÅ‰øùÊä§ÊúâËøáÊ¨†Âéã„ÄÅËøáÊ∏©„ÄÅÂ†µËΩ¨„ÄÅÂêØÂä®„ÄÅÁº∫Áõ∏Á≠â‰øùÊä§ÔºåË∞ÉËØïÊó∂ÔºåÂèØÊ†πÊ
             -çÆÈúÄÊ±ÇÔºå‰∏Ä‰∏™‰∏™ÁöÑË∞ÉËØïÂä†ÂÖ•„ÄÇ
 813          /*---------------------------------------------------------------------------*/
 814          void Fault_Detection(void)
 815          {
 816   1          mcFaultDect.segment++;
 817   1          if(mcFaultDect.segment>=5)
 818   1          {
 819   2            mcFaultDect.segment=0;
 820   2          }
 821   1          if(mcFaultDect.segment==0)
 822   1          {
 823   2            if(CurrentRecoverEnable)//ËøáÊµÅ‰øùÊä§ÊÅ¢Â§ç‰ΩøËÉΩ
 824   2            {
 825   3              Fault_OverCurrentRecover(&mcFaultDect);
 826   3            }
 827   2            if(PowerRecoverEnable) //ÂäüÁéá‰øùÊä§ÊÅ¢Â§ç‰ΩøËÉΩ
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 15  

 828   2            {
 829   3              Fault_OverPowerRecover(&mcFaultDect);
 830   3            }
 831   2            
 832   2          }
 833   1          else if(mcFaultDect.segment==1)
 834   1          {
 835   2            if((VoltageProtectEnable==1)&&(test_flag == 0))//ËøáÂéã‰øùÊä§‰ΩøËÉΩ
 836   2            {
 837   3              Fault_OverUnderVoltage(&mcFaultDect);
 838   3            }
 839   2            
 840   2            if(OverPowerProtectEnable==1); //ÂäüÁéá‰øùÊä§‰ΩøËÉΩ
 841   2            {
 842   3              Fault_Power(&mcFaultDect);
 843   3            }       
 844   2          }
 845   1          else if(mcFaultDect.segment==2)
 846   1          {
 847   2            if(StartProtectEnable==1)//ÂêØÂä®‰øùÊä§‰ΩøËÉΩ
 848   2            {
 849   3              Fault_Start(&mcFaultDect);
 850   3            }
 851   2          }
 852   1          else if(mcFaultDect.segment==3)
 853   1          {
 854   2            if(StallProtectEnable==1)//Â†µËΩ¨‰øùÊä§‰ΩøËÉΩ
 855   2            {
 856   3              Fault_Stall(&mcFaultDect,&mcCurVarible);
 857   3            }
 858   2          }
 859   1          else if(mcFaultDect.segment==4)
 860   1          {
 861   2            if(PhaseLossProtectEnable==1)//Áº∫Áõ∏‰øùÊä§‰ΩøËÉΩ
 862   2            {
 863   3              Fault_phaseloss(&mcFaultDect);
 864   3            }
 865   2            
 866   2          }
 867   1          else
 868   1          {
 869   2      
 870   2          }
 871   1      }
 872          
 873          /*---------------------------------------------------------------------------*/
 874          /* Name   : void ONOFF_Starttest(void)
 875          /* Input  : NO
 876          /* Output : NO
 877          /* Description: ÂêØÂä®ÊµãËØï
 878          /*---------------------------------------------------------------------------*/
 879          void ONOFF_Starttest(ONVarible  *h_test)
 880          {
 881   1        if(h_test->ONOFF_Flag==1)
 882   1        {
 883   2           h_test->ON_Count++;
 884   2          if(h_test->ON_Count>StartON_Time)
 885   2          {
 886   3            h_test->ON_Count=0;
 887   3            h_test->ONOFF_Times++;
 888   3            h_test->ONOFF_Flag=0;
 889   3            mcSpeedRamp.FlagONOFF = 0;
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 16  

 890   3            mcSpeedRamp.TargetValue = 0;
 891   3      
 892   3          }
 893   2        }
 894   1        else
 895   1        {
 896   2          if(mcState!=mcFault)
 897   2          {
 898   3            h_test->OFF_Count++;
 899   3            if(h_test->OFF_Count>StartOFF_Time)
 900   3            {
 901   4              h_test->OFF_Count=0;
 902   4              h_test->ONOFF_Flag=1;
 903   4              mcSpeedRamp.FlagONOFF = 1;
 904   4              mcSpeedRamp.TargetValue = Motor_Test_Speed;
 905   4      
 906   4            }
 907   3          }
 908   2      
 909   2        }
 910   1      }
 911          
 912          /*---------------------------------------------------------------------------*/
 913          /* Name   : void Speed_response(void)
 914          /* Input  : NO
 915          /* Output : NO
 916          /* Description: ÈÄüÂ∫¶ÂìçÂ∫îÂáΩÊï∞ÔºåÂèØÊ†πÊçÆÈúÄÊ±ÇÂä†ÂÖ•ÊéßÂà∂ÁéØÔºåÂ¶ÇÊÅíËΩ¨Áü©ÊéßÂà∂„ÄÅÊÅíËΩ¨ÈÄüÊéßÂà∂
             -„ÄÅÊÅíÂäüÁéáÊéßÂà∂
 917          /*---------------------------------------------------------------------------*/
 918          
 919          
 920          void Speed_response(void)
 921          {
 922   1          uint16  UqMinTemp = 0;     //UQÈôêÂπÖÊúÄÂ∞èÂÄºÁºìÂ≠òÂèòÈáè
 923   1        
 924   1          if((mcState ==mcRun)||(mcState ==mcStop))
 925   1          { 
 926   2              mcSpeedRamp.IncValue  = SPEEDRAMPINC;             //ËøêË°åÈÄüÂ∫¶ÁéØÂ¢ûÈáè
 927   2              mcSpeedRamp.DecValue  = SPEEDRAMPDEC;
 928   2                
 929   2            switch(mcFocCtrl.CtrlMode)
 930   2            {
 931   3              case 0:
 932   3              {
 933   4                  if(FOC__EOME > Motor_Loop_Speed)//>=MOTOR_LOOP_RPM
 934   4                  {
 935   5                    FOC__THECOMP  = _Q15(0.0/180.0);                        // SMO ‰º∞ÁÆóË°•ÂÅøËßí
 936   5                    FOC__THECOR     = 0x04;   
 937   5                    mcFocCtrl.CtrlMode = 1;
 938   5                    FOC_DQKP = DQKP;
 939   5                    FOC_DQKI = DQKI;
 940   5                    FOC_QMAX      = QOUTMAX;
 941   5                    # if (Motor_Speed_Control_Mode == SPEED_LOOP_CONTROL)
 942   5                    {
 943   6                         mcSpeedRamp.ActualValue = FOC__EOME ;  //Èò≤Ê≠¢mcSpeedRamp.ActualValue‰ªé0ÂºÄÂßãÁà¨Âù°ÔºåÈÄ†Êàê
             -‰º∞ÁÆóÂºÇÂ∏∏ÔºåÁîµÊµÅÂºÇÂ∏∏
 944   6                    }
 945   5                    #elif (Motor_Speed_Control_Mode == POWER_LOOP_CONTROL)
                            {
                              mcSpeedRamp.ActualValue = mcFocCtrl.Powerlpf;
                            }
                            #endif
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 17  

 950   5                    
 951   5                    OutLoopParameterSet();       //ÁéØË∑ØÂü∫Êú¨ÂèÇÊï∞ËÆæÁΩÆ
 952   5                  }
 953   4                  else
 954   4                  {
 955   5                    
 956   5      //              if(FOC_IQREF < I_Value(0.6))
 957   5      //              {
 958   5      //                FOC_IQREF += 1;
 959   5      //              }
 960   5                    
 961   5      //              UqMinTemp = FOC_QMIN;
 962   5      //              if(UqMinTemp < QOUTMINSTEND)
 963   5      //              {
 964   5      //                UqMinTemp += 10 ;
 965   5      //                FOC_QMIN = UqMinTemp;
 966   5      //              }
 967   5                  }
 968   4                }
 969   3                break;
 970   3                case 1:
 971   3                {
 972   4                              
 973   4                  #if (OUTLoop_Mode== OUTLoop_Disable)
                          {
                              mcFocCtrl.mcIqref = FOC_IQREF;
                              if (FOC_IQREF < QOUTVALUE)
                              {
                                  mcFocCtrl.mcIqref += QOUTINC;
                                  if (mcFocCtrl.mcIqref > QOUTVALUE) mcFocCtrl.mcIqref = QOUTVALUE;
                                  FOC_IQREF = mcFocCtrl.mcIqref;
                              }
                              else if (FOC_IQREF > QOUTVALUE)
                              {
                                  mcFocCtrl.mcIqref -= QOUTINC;
                                  if (mcFocCtrl.mcIqref < QOUTVALUE) mcFocCtrl.mcIqref = QOUTVALUE;
                                  FOC_IQREF = mcFocCtrl.mcIqref;
                              }
                          }
              
                          #elif (OUTLoop_Mode== OUTLoop_Enable)
 991   4                  {
 992   5                      mcFocCtrl.SpeedRampTime++;
 993   5                      if(mcFocCtrl.SpeedRampTime > SPEEDRAMPTIME)
 994   5                      {
 995   6                          mcFocCtrl.SpeedRampTime = 0;
 996   6                          mc_ramp(&mcSpeedRamp);       //Â§ñÁéØÈÄüÂ∫¶Áà¨Âù°ÊàñÂáèÈÄü„ÄÇÊØèSpeedRampTimeÊâßË°å‰∏ÄÊ¨°
 997   6                      }
 998   5                      
 999   5                      mcFocCtrl.SpeedLoopTime++;
1000   5                      if(mcFocCtrl.SpeedLoopTime > SPEED_LOOP_TIME)  //Â§ñÁéØË∞ÉËäÇÂë®Êúü
1001   5                      {
1002   6                          mcFocCtrl.SpeedLoopTime=0;
1003   6      
1004   6                          #if (Motor_Speed_Control_Mode == SPEED_LOOP_CONTROL)
1005   6                          {             
1006   7                            SpeedPICtrl.ExtRef = mcSpeedRamp.ActualValue;
1007   7                            SpeedPICtrl.ExtFed = mcFocCtrl.SpeedFlt;
1008   7                            
1009   7                            if(mcFocCtrl.SpeedFlt <(_Q15(80000 / MOTOR_SPEED_BASE)))
1010   7                            {
1011   8                              PI_KP       = SKP;
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 18  

1012   8                              PI_KI       = SKI;
1013   8                            }
1014   7                            else
1015   7                            {
1016   8                              mcSpeedRamp.IncValue  = SPEEDRAMPINC /5;              //ËøêË°åÈÄüÂ∫¶ÁéØÂ¢ûÈáè
1017   8                              mcSpeedRamp.DecValue  = SPEEDRAMPDEC /5;
1018   8                              PI_KP       = SKPH;
1019   8                              PI_KI       = SKIH;
1020   8                            }
1021   7                            HW_PI_Control(&SpeedPICtrl);             //
1022   7                            FOC_IQREF = SpeedPICtrl.ExtOut;
1023   7                          }
1024   6                          #elif (Motor_Speed_Control_Mode == POWER_LOOP_CONTROL)
                                  {
                                     FOC_IQREF= HW_One_PI(mcSpeedRamp.ActualValue- mcFocCtrl.Powerlpf);
                                  }
                                  #endif
1029   6                      }
1030   5                      
1031   5      
1032   5                // Âà§Êñ≠FOC_QMINÂÄºÊÅ¢Â§çÂà∞Ê≠£Â∏∏ÂÄº
1033   5      //          UqMinTemp = FOC_QMIN;
1034   5      //          if(UqMinTemp > QOUTMIN)
1035   5      //          {
1036   5      //            UqMinTemp -- ;
1037   5      //            FOC_QMIN = UqMinTemp;
1038   5      //          } 
1039   5                      
1040   5                 }
1041   4                 #endif //END OUTLoop_Mode
1042   4      
1043   4      
1044   4                 if(FOC_EK2 < OBS_K2T_Actual-10)
1045   4                 {
1046   5                   mcFocCtrl.Smo_EK2=FOC_EK2;
1047   5                   mcFocCtrl.Smo_EK2+=10;
1048   5                   FOC_EK2=mcFocCtrl.Smo_EK2;
1049   5                 }
1050   4                 else if(FOC_EK2 > OBS_K2T_Actual+10)
1051   4                 {
1052   5                   mcFocCtrl.Smo_EK2=FOC_EK2;
1053   5                   mcFocCtrl.Smo_EK2-=10;
1054   5                   FOC_EK2=mcFocCtrl.Smo_EK2;
1055   5                 }
1056   4                 else
1057   4                 {
1058   5                   FOC_EK2=OBS_K2T_Actual;
1059   5                 }
1060   4                  
1061   4              }
1062   3              break;
1063   3            }
1064   2          }
1065   1      
1066   1      }
1067          
1068          
1069          /*---------------------------------------------------------------------------*/
1070          /* Name   : void FGOutput(void)
1071          /* Input  : NO
1072          /* Output : NO
1073          /* Description: FG‰ø°Âè∑ËæìÂá∫
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 19  

1074          /*---------------------------------------------------------------------------*/
1075          void FGOutput(void)
1076          {//FGÂèØÁî®‰∏≠Êñ≠FGIFËøõË°åÂà§Êñ≠
1077   1        if(mcState==mcRun)
1078   1        {
1079   2          if((FOC__THETA>=0)&&(FOC__THETA<32768))//0-180
1080   2          {
1081   3            ResetFGPin;
1082   3          }
1083   2          else if((FOC__THETA>=32768)&&(FOC__THETA<65536))//180-360
1084   2          {
1085   3            SetFGPin;
1086   3          }
1087   2        }
1088   1        else if(mcState == mcFault)
1089   1        {
1090   2            SetFGPin;
1091   2        }
1092   1        else
1093   1        {
1094   2            ResetFGPin;
1095   2        }
1096   1      }
1097          /*---------------------------------------------------------------------------*/
1098          /* Name   :  uint16 SoftLPF(uint16 Xn1, uint16 Xn0, uint16 K)
1099          /* Input  : uint16 Xn1, uint16 Xn0, uint16 K
1100          /* Output : uint16
1101          /* Description: ËΩØ‰ª∂‰ΩéÈÄöÊª§Ê≥¢
1102          /*---------------------------------------------------------------------------*/
1103           int16 SoftLPF(int16 Xn1, int16 Xn0, int16 K)
1104           {
1105   1         int16 Temp16 = 0;
1106   1         int32 Temp32 = 0;
1107   1      
1108   1         Temp32 = (((int32)Xn1 - (int32)Xn0) * (int32)K) >> 15;
1109   1         Temp16 = Xn0 + (int16)Temp32;
1110   1         return Temp16;
1111   1       }
1112          
1113          
1114          /*---------------------------------------------------------------------------*/
1115          /* Name   : void LED_Display(void)
1116          /* Input  : NO
1117          /* Output : NO
1118          /* Description: LEDÁÅØÊòæÁ§∫
1119          /*---------------------------------------------------------------------------*/
1120          void LED_Display(void)
1121          {
1122   1        switch(mcFaultSource)
1123   1        {
1124   2          case FaultNoSource:
1125   2          SetLEDPin;                          //‰ΩéÁîµÂπ≥ÁÇπ‰∫ÆÔºåÈ´òÁîµÂπ≥ÁÅ≠
1126   2            break;
1127   2          case FaultHardOVCurrent:             //Á°¨‰ª∂ËøáÊµÅ‰øùÊä§Èó™ÁÉÅ10Ê¨°           
1128   2              Led_OnOff(&mcLedDisplay,10);
1129   2            break;
1130   2          case FaultSoftOVCurrent:            //ËΩØ‰ª∂ËøáÊµÅ‰øùÊä§Èó™ÁÉÅ4Ê¨°           
1131   2              Led_OnOff(&mcLedDisplay,4);
1132   2            break;
1133   2          case FaultUnderVoltage:              //Ê¨†Âéã‰øùÊä§Èó™ÁÉÅ2Ê¨°
1134   2              Led_OnOff(&mcLedDisplay,2);
1135   2            break;
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 20  

1136   2          case FaultOverVoltage:                //ËøáÂéã‰øùÊä§Èó™ÁÉÅ3Ê¨°
1137   2              Led_OnOff(&mcLedDisplay,3);
1138   2            break;
1139   2          case FaultLossPhase:                  //Áº∫Áõ∏‰øùÊä§Èó™ÁÉÅ8Ê¨°
1140   2              Led_OnOff(&mcLedDisplay,5);
1141   2            break;
1142   2          case FaultStall:                     //Â†µËΩ¨‰øùÊä§Èó™ÁÉÅ6Ê¨°
1143   2              Led_OnOff(&mcLedDisplay,6);
1144   2            break;
1145   2          case  FaultOverPower:               //ÂäüÁéá‰øùÊä§Èó™ÁÉÅ7Ê¨°
1146   2              Led_OnOff(&mcLedDisplay,7);
1147   2            break;
1148   2      
1149   2          default:
1150   2            break;
1151   2        }
1152   1      
1153   1      }
1154          
1155            //LEDÁÅØÁöÑÈó™ÁÉÅ
1156          void Led_OnOff(MCLedDisplay *hLedDisplay,uint8 htime)
1157          {
1158   1        hLedDisplay->LedCount++;
1159   1        if(hLedDisplay->LedCount<hLedDisplay->Counttime)
1160   1         {
1161   2            if(hLedDisplay->Count<200)
1162   2            {
1163   3             hLedDisplay->Count++;
1164   3      
1165   3            }
1166   2            else if((hLedDisplay->Count>=200)&&(hLedDisplay->Count<201))
1167   2            {
1168   3              hLedDisplay->Count=0;
1169   3              LEDPinONOFF;
1170   3              hLedDisplay->LedTimCot++;
1171   3            }
1172   2            else
1173   2              ;
1174   2            if(hLedDisplay->LedTimCot>=2*htime)
1175   2            {
1176   3              hLedDisplay->Count=202;
1177   3              SetLEDPin;
1178   3            }
1179   2          }
1180   1          else if(hLedDisplay->LedCount>=hLedDisplay->Counttime)
1181   1          {
1182   2           hLedDisplay->LedCount=0;
1183   2           hLedDisplay->LedTimCot=0;
1184   2           hLedDisplay->Count=0;
1185   2          }
1186   1      }
1187          /*---------------------------------------------------------------------------*/
1188          /* Name   : void mc_ramp(void)
1189          /* Input  : hTarget,MC_RAMP *hSpeedramp
1190          /* Output : NO
1191          /* Description:
1192          /*---------------------------------------------------------------------------*/
1193          
1194          void mc_ramp(MCRAMP *hSpeedramp)
1195          {
1196   1      //  if( --hSpeedramp->DelayCount < 0)
1197   1      //  {
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 21  

1198   1      //    hSpeedramp->DelayCount = hSpeedramp->DelayPeriod;
1199   1      
1200   1          if (hSpeedramp->ActualValue < hSpeedramp->TargetValue)
1201   1          {
1202   2              if(hSpeedramp->ActualValue + hSpeedramp->IncValue < hSpeedramp->TargetValue)
1203   2              {
1204   3                  hSpeedramp->ActualValue += hSpeedramp->IncValue;
1205   3              }
1206   2              else
1207   2              {
1208   3                  hSpeedramp->ActualValue = hSpeedramp->TargetValue;
1209   3              }
1210   2          }
1211   1          else
1212   1          {
1213   2              if(hSpeedramp->ActualValue - hSpeedramp->DecValue > hSpeedramp->TargetValue)
1214   2              {
1215   3      
1216   3                  hSpeedramp->ActualValue -= hSpeedramp->DecValue;
1217   3              }
1218   2              else
1219   2              {
1220   3                  hSpeedramp->ActualValue = hSpeedramp->TargetValue;
1221   3              }
1222   2          }
1223   1      //  }
1224   1      }
1225          
1226          /*-------------------------------------------------------------------------------------------------
1227            Function Name : int16 HW_One_PI(int16 Xn1, int16 Yn0, int16 Xn2)
1228            Description   : PIÊéßÂà∂
1229            Input         : Xn1--E(K)
1230            Output      : PI_UK--ÂΩìÂâçPIËæìÂá∫ÂÄº,ÊâßË°åÊó∂Èó¥us
1231          -------------------------------------------------------------------------------------------------*/
1232          int16 HW_One_PI(int16 Xn1)
1233          {
1234   1          PI_EK =  Xn1;                               //Â°´ÂÖ•EK
1235   1          SetBit(PI_LPF_CR,PISTA);                    // Start PI
1236   1      //    PI_LPF_CR |= 0x02;                          // Start PI
1237   1          _nop_();  _nop_();  _nop_();  _nop_();  _nop_();
1238   1          PI_UK += ((SKP>>12) +1);
1239   1          return PI_UK;
1240   1      }
1241          
1242          void HW_PI_Control(OUTLOOP *PIPara)
1243          {   
1244   1          PI_EK =  PIPara->ExtErr;                                                    //Â°´ÂÖ•Êú¨Ê¨°EK ËØØÂ∑ÆÂÄº
1245   1          SetBit(PI_LPF_CR,PISTA);                                                    // Start PI
1246   1          _nop_();  _nop_();  _nop_();  _nop_();  _nop_();
1247   1        
1248   1          PI_UK     = PIPara->ExtOutL;
1249   1          PI_UKMAX  = SOUTMAX;
1250   1          PI_UKMIN  = SOUTMIN;
1251   1          PIPara->ExtErr = PIPara->ExtRef - PIPara->ExtFed;
1252   1          PI_EK =  PIPara->ExtErr;
1253   1        
1254   1          SetBit(PI_LPF_CR,PISTA);                                                    // Start PI
1255   1          _nop_();  _nop_();  _nop_();  _nop_();  _nop_();
1256   1          PIPara->ExtOut = PI_UK + 1;                                                 // Ë°•ÂÅøPIËæìÂá∫ËØØÂ∑Æ
1257   1          PIPara->ExtOutL= PIPara->ExtOut;
1258   1          
1259   1      }
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 22  

1260          
1261          /*-------------------------------------------------------------------------------------------------
1262            Function Name : int16 LPF(int16 Xn1, int16 Xn0, int8 K)
1263            Description   : LFPÊéßÂà∂
1264            Input         : Xn1--ÂΩìÂâçËæìÂÖ•ÂÄº
1265                            Xn0--‰∏ä‰∏ÄÊ¨°Êª§Ê≥¢ËæìÂá∫ÂÄº
1266                            K--LPFÊª§Ê≥¢Á≥ªÊï∞
1267            Output        : LPF_Y--ÂΩìÂâçÊª§Ê≥¢ËæìÂá∫ÂÄºÔºåÊâßË°åÊó∂Èó¥‰∏∫4us„ÄÇ
1268          -------------------------------------------------------------------------------------------------*/
1269          int16 LPFFunction(int16 Xn1, int16 Xn0, int8 K)
1270          {
1271   1        LPF_K = K;
1272   1        LPF_X = Xn1;
1273   1        LPF_Y = Xn0;
1274   1        SetBit(PI_LPF_CR, LPFSTA);
1275   1        _nop_();_nop_();_nop_();_nop_();_nop_();
1276   1        return LPF_Y;
1277   1      }
1278          
1279          /*---------------------------------------------------------------------------*/
1280          /* Name   : void VSPSample(void)
1281          /* Input  : NO
1282          /* Output : NO
1283          /* Description: VSPÈááÊ†∑
1284          /*---------------------------------------------------------------------------*/
1285          void VSPSample(void)
1286          {
1287   1        /*****VREFÁöÑÈááÊ†∑Ëé∑ÂèñÂÄºÂπ∂Êª§Ê≥¢******/
1288   1        AdcSampleValue.ADCVref = (ADC7_DR<<3);//ÈááÈõÜÂØπÂ∫îÁ´ØÂè£
1289   1        VSP=LPFFunction(AdcSampleValue.ADCVref,VSP,30);//‰ΩéÈÄöÊª§Ê≥¢
1290   1      
1291   1          if((VSP > ONPWMDuty)&&(VSP <= OFFPWMDutyHigh))//Âú®ONPWMDuty-OFFPWMDutyHigh‰πãÈó¥ÔºåÁîµÊú∫ÊúâËΩ¨ÈÄüËøêË
             -°å
1292   1          {
1293   2            mcSpeedRamp.FlagONOFF = 1;
1294   2          }
1295   1          else if((VSP < OFFPWMDuty)||(VSP > OFFPWMDutyHigh))//ÁîµÊú∫ÂÅúÊú∫
1296   1          {
1297   2            mcSpeedRamp.FlagONOFF = 0;
1298   2          }
1299   1          //ËΩ¨ÈÄüÊõ≤Á∫øËÆ°ÁÆó
1300   1          if(mcSpeedRamp.FlagONOFF==1)//
1301   1          {
1302   2            #if (Motor_Speed_Control_Mode == SPEED_LOOP_CONTROL)
1303   2            {
1304   3              if(VSP <= MINPWMDuty)    //ÊúÄÂ∞èËΩ¨ÈÄüËøêË°å
1305   3              {
1306   4                mcSpeedRamp.TargetValue = Motor_Min_Speed;
1307   4              }
1308   3              else if(VSP < MAXPWMDuty)//Ë∞ÉÈÄü
1309   3              {
1310   4                mcSpeedRamp.TargetValue = Motor_Min_Speed + SPEED_K*(VSP-MINPWMDuty);
1311   4              }
1312   3              else         //ÊúÄÂ§ßËΩ¨ÈÄüËøêË°å
1313   3              {
1314   4                mcSpeedRamp.TargetValue = Motor_Max_Speed;
1315   4              }
1316   3            }
1317   2            #elif (Motor_Speed_Control_Mode == POWER_LOOP_CONTROL)
                    {
                      if(VSP <= MINPWMDuty)    //ÊúÄÂ∞èËΩ¨ÈÄüËøêË°å
                      {
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 23  

                        mcSpeedRamp.TargetValue = Motor_Min_Power;
                      }
                      else if(VSP < MAXPWMDuty)//Ë∞ÉÈÄü
                      {
                        mcSpeedRamp.TargetValue = Motor_Min_Power + POWER_K*(VSP-MINPWMDuty);
                      }
                      else         //ÊúÄÂ§ßËΩ¨ÈÄüËøêË°å
                      {
                        mcSpeedRamp.TargetValue = Motor_Max_Power;
                      }
                    }
                    #endif
1333   2      
1334   2          }
1335   1          else
1336   1          {
1337   2            mcSpeedRamp.TargetValue =0;
1338   2          }
1339   1      }
1340          /*---------------------------------------------------------------------------*/
1341          /* Name   : void Sleepmode(void)
1342          /* Input  : NO
1343          /* Output : NO
1344          /* Description: Áù°Áú†Ê®°ÂºèÊµãËØï
1345          /*---------------------------------------------------------------------------*/
1346           void Sleepmode(void)
1347           {
1348   1          SleepSet.SleepDelayCout++;
1349   1          if(SleepSet.SleepDelayCout>=20000)//ÊúÄÂ§ß65530ÔºåËã•Ë¶ÅÂÜçÂ§ßÔºåÈúÄÊîπÊï∞ÊçÆÁ±ªÂûã
1350   1          {
1351   2      //        FOC_EFREQMIN  = -Motor_Omega_Ramp_Min;
1352   2      //        FOC_EFREQHOLD = -Motor_Omega_Ramp_End;
1353   2            mcSpeedRamp.TargetValue=0;
1354   2            MOE     = 0;
1355   2            ClrBit(DRV_CR, FOCEN);  //ÂÖ≥Èó≠FOC
1356   2            SleepSet.SleepDelayCout=0;
1357   2            SleepSet.SleepFlag=1;
1358   2            SetBit(P1_IE, P11);   // config P11 as the source of EXTI1
1359   2            SetBit(PCON, STOP);
1360   2          }
1361   1      
1362   1       }
1363          /*---------------------------------------------------------------------------*/
1364          /* Name   : void StarRampDealwith(void)
1365          /* Input  : NO
1366          /* Output : NO
1367          /* Description:
1368          /*---------------------------------------------------------------------------*/
1369          void StarRampDealwith(void)
1370          {
1371   1          if((mcState == mcRun))
1372   1          {
1373   2            if(mcFocCtrl.State_Count == 100)//2300
1374   2            {
1375   3              FOC_EKP = OBSW_KP_GAIN_RUN;                           // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKP
1376   3              FOC_EKI = OBSW_KI_GAIN_RUN;                           // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKI
1377   3            }
1378   2            else if(mcFocCtrl.State_Count == 60)//2000
1379   2            {
1380   3              FOC_EKP = OBSW_KP_GAIN_RUN1;                          // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKP
1381   3              FOC_EKI = OBSW_KI_GAIN_RUN1;                          // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKI
1382   3            }
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/16/2020 10:07:49 PAGE 24  

1383   2            else if(mcFocCtrl.State_Count == 40)//1600
1384   2            {
1385   3              FOC_EKP = OBSW_KP_GAIN_RUN2;                          // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKP
1386   3              FOC_EKI = OBSW_KI_GAIN_RUN2;                          // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKI
1387   3            }
1388   2            else if(mcFocCtrl.State_Count ==20)//1200
1389   2            {
1390   3              FOC_EKP = OBSW_KP_GAIN_RUN3;                          // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKP
1391   3              FOC_EKI = OBSW_KI_GAIN_RUN3;                          // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKI
1392   3            }
1393   2            else if(mcFocCtrl.State_Count == 10)
1394   2            {
1395   3              FOC_EKP = OBSW_KP_GAIN_RUN4;                          // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKP
1396   3              FOC_EKI = OBSW_KI_GAIN_RUN4;                          // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKI
1397   3            }
1398   2            else;
1399   2          }
1400   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5962    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    146      42
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =    132    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
