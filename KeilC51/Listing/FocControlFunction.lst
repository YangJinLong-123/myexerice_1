C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE FOCCONTROLFUNCTION
OBJECT MODULE PLACED IN .\Output\FocControlFunction.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\User\Source\Function\FocControlFunction.c LARGE OMF2 WARNINGLEVEL(0) OP
                    -TIMIZE(5,SPEED) BROWSE INCDIR(..\Library\FU68xx_Hardware_Driver\Include;..\User\Include) DEBUG PRINT(.\Listing\FocContro
                    -lFunction.lst) TABS(2) OBJECT(.\Output\FocControlFunction.obj)

line level    source

   1          /**************************** (C) COPYRIGHT 2017 Fortiortech shenzhen *****************************
   2          * File Name          : FocControl.c
   3          * Author             : Fortiortech  Appliction Team
   4          * Version            : V1.0
   5          * Date               : 10-Apr-2017
   6          * Description        : This file contains all the foc control function used for motor control.
   7          ***************************************************************************************************
   8          * All Rights Reserved
   9          **************************************************************************************************/
  10          
  11          
  12          /* Includes -------------------------------------------------------------------------------------*/
  13          #include <FU68xx_2.h>
  14          #include <Myproject.h>
  15          #include <FU68xx_2_DMA.h>
  16          #endif
  17          CurrentOffset xdata mcCurOffset;
  18          
  19          /*---------------------------------------------------------------------------*/
  20          /* Name   : void FOC_Init(void)
  21          /* Input  : NO
  22          /* Output : NO
  23          /* Description: mcInitçŠ¶æ€ä¸‹ï¼Œå¯¹FOCçš„ç›¸å…³å¯„å­˜å™¨è¿›è¡Œé…ç½®,å…ˆæ¸…ç†å¯„å­˜å™¨ï¼Œåé…ç½®ï¼Œæœ
             -€åä½¿èƒ½
  24          /*---------------------------------------------------------------------------*/
  25          void FOC_Init(void)
  26          {
  27   1        /*ä½¿èƒ½FOC*/
  28   1        ClrBit(DRV_CR, FOCEN);
  29   1        SetBit(DRV_CR, FOCEN);
  30   1        /*é…ç½®FOCå¯„å­˜å™¨*/
  31   1        FOC_CR1       = 0;                                      // æ¸…é›¶ FOC_CR1
  32   1        FOC_CR2       = 0;                                      // æ¸…é›¶ FOC_CR2
  33   1        FOC_IDREF     = 0;                                      // æ¸…é›¶ Id
  34   1        FOC_IQREF     = 0;                                      // æ¸…é›¶ Iq
  35   1      
  36   1        FOC__THETA    = 0;                                      // æ¸…é›¶ è§’åº¦
  37   1        FOC_RTHEACC   = 0;                                      // æ¸…é›¶ çˆ¬å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
  38   1        FOC__RTHESTEP   = 0;                                    //
  39   1        FOC__RTHECNT  = 0;                                      //
  40   1        FOC__THECOMP  = _Q15(2.0/180.0);                        // SMO ä¼°ç®—è¡¥å¿è§’
  41   1        FOC__THECOR     = 0x02;                                 // è¯¯å·®è§’åº¦è¡¥å¿
  42   1      
  43   1        /*ç”µæµç¯å‚æ•°é…ç½®*/
  44   1        FOC_DMAX      = DOUTMAX;
  45   1        FOC_DMIN      = DOUTMIN;
  46   1      
  47   1        FOC_QMAX      = QOUTMAX;
  48   1        FOC_QMIN      = QOUTMIN;
  49   1      
  50   1        /*ä½ç½®ä¼°ç®—å‚æ•°é…ç½®*/
  51   1        FOC_EK1       = OBS_K1T;
  52   1        FOC_EK2       = OBS_K2T;
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 2   

  53   1        FOC_EK3       = OBS_K3T;
  54   1        FOC_EK4       = OBS_K4T;
  55   1        FOC_FBASE     = OBS_FBASE;
  56   1        FOC_OMEKLPF   = SPEED_KLPF;
  57   1        FOC_EBMFK     = OBS_KLPF;
  58   1      
  59   1        FOC_TGLI      = PWM_TGLI_LOAD;
  60   1      
  61   1        /*********PLLæˆ–SMO**********/
  62   1        #if (EstimateAlgorithm == SMO)
  63   1        {
  64   2            ClrBit(FOC_CR2, ESEL);
  65   2            FOC_KSLIDE    = OBS_KSLIDE;
  66   2            FOC_EKLPFMIN  = OBS_EA_KS;
  67   2        }
  68   1        #elif (EstimateAlgorithm == PLL)
                {
                    SetBit(FOC_CR2, ESEL);
                    FOC_KSLIDE    = OBSE_PLLKP_GAIN;
                    FOC_EKLPFMIN  = OBSE_PLLKI_GAIN;
                }
                #endif //end SVPMW_Mode
  75   1      
  76   1        SetBit(FOC_CR1, SVPWMEN);                             // SVPWMæ¨¡å¼
  77   1      
  78   1      //  /*æ­£åè½¬*/
  79   1      //  if(mcFRState.FR==1)                                 // è®¾ç½®F/R
  80   1      //  {
  81   1      //    SetBit(DRV_CR,DRV_DDIR);
  82   1      //  }
  83   1      //  else
  84   1      //  {
  85   1      //    ClrBit(DRV_CR,DRV_DDIR);
  86   1      //  }
  87   1        #if ( IRMODE==1)
  88   1        {
  89   2          SetBit(DRV_CR,DDIR);                               // åè½¬æ ‡å¿—ä½
  90   2        }
  91   1        #endif //end IRMODE
  92   1      
  93   1        /**è¿‡è°ƒåˆ¶**/
  94   1        #if (OverModulation == 1)
                {
                    SetBit(FOC_CR1,OVMDL);                          // è¿‡è°ƒåˆ¶
                }
                #endif //end OverModulation
  99   1      
 100   1        /*å•ç”µé˜»é‡‡æ ·ï¼›éœ€è¦æœ€å°é‡‡æ ·çª—,FOC_TRGDLYä¸º0ï¼Œä¸ƒæ®µå¼SVPWMæ–¹å¼*/
 101   1        #if (Shunt_Resistor_Mode == Single_Resistor)
 102   1        {
 103   2          SetReg(FOC_CR1, CSM0 | CSM1, 0x00);
 104   2          FOC_TSMIN = PWM_TS_LOAD;                              // æœ€å°é‡‡æ ·çª—å£
 105   2          FOC_TRGDLY = 0x08;                                    // é‡‡æ ·æ—¶åˆ»åœ¨ä¸­ç‚¹ï¼Œä¸€èˆ¬è€ƒè™‘å¼€å…³å™ªå£°å½±å“ï¼Œä¼š
             -è®¾ç½®å»¶è¿Ÿï¼›0x08
 106   2                                                                // 0x0cè¡¨ç¤ºå»¶è¿Ÿ12ä¸ªclockï¼Œæå‰ç”¨åç å½¢
             -å¼ï¼Œå¦‚0x84è¡¨ç¤ºæå‰12ä¸ªclockã€‚
 107   2          ClrBit(FOC_CR2,F5SEG);                                // 7æ®µå¼
 108   2          SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, 0x00);
 109   2        }
 110   1        /*åŒç”µé˜»é‡‡æ ·ï¼Œå¯è®¾ç½®æ­»åŒºè¡¥å¿å€¼ï¼Œåœ¨ä¸‹é™æ²¿ç»“æŸå‰å¼€å§‹é‡‡æ ·Iaï¼Œé…ç½®81*/
 111   1        #elif (Shunt_Resistor_Mode == Double_Resistor)          // double resistor sample
                {
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 3   

                  SetReg(FOC_CR1, CSM0 | CSM1, CSM0);
              
                  FOC_TSMIN = PWM_DT_LOAD;                              // æ­»åŒºè¡¥å¿å€¼
                  FOC_TRGDLY = 0x83;                                    // ADCé‡‡æ ·çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å™¨é›¶ç‚¹é™„è¿‘ï¼Œ83ä¸
             -ºä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒ
                                                                        // 01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ
             - ·ã€‚æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚
                  FOC_TBLO=PWM_DLOWL_TIME;                              //ä¸‹æ¡¥è‡‚æœ€å°è„‰å†²ï¼Œä¿è¯é‡‡æ ·
                  SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, 0x00);
              
                  /*äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹©*/
                  #if (SVPMW_Mode == SVPWM_7_Segment)
                  {
                    ClrBit(FOC_CR2,F5SEG);                              // 7æ®µå¼
                  }
                  #elif (SVPMW_Mode == SVPWM_5_Segment)
                  {
                    SetBit(FOC_CR2,F5SEG);                              // 7æ®µå¼
                  }
                  #endif
              
                  #if (DouRes_Sample_Mode == DouRes_1_Cycle)
                  {
                    ClrBit(FOC_CR2,DSS);                                // 7æ®µå¼
                  }
                  #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
                  {
                    SetBit(FOC_CR2,FOC_DSS);                            // 7æ®µå¼
                  }
                  #endif //end DouRes_Sample_Mode
                }
                /*ä¸‰ç”µé˜»é‡‡æ ·*/
                #elif (Shunt_Resistor_Mode == Three_Resistor)           // signel resistor sample
                {
              
                  SetReg(FOC_CR1, CSM0 | CSM1, CSM0 | CSM1);// ä¸‰ç”µé˜»
              
                  FOC_TSMIN  = PWM_DT_LOAD;                             // æ­»åŒºè¡¥å¿å€¼
                  FOC_TRGDLY =06;                                       // ADCé‡‡æ ·çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å™¨é›¶ç‚¹é™„è¿‘ï¼Œ83ä¸º
             -ä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒã€‚
                                                                        // 01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ
             - ·ã€‚æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚
              
                  SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, CMP3MOD0 | CMP3MOD1);
                  FOC_TBLO= PWM_OVERMODULE_TIME;                        // è¿‡è°ƒåˆ¶ç”µæµé‡‡æ ·å¤„ç†çš„TBè„‰å®½
              
                  /*äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹©*/
                  #if (SVPMW_Mode == SVPWM_7_Segment)
                  {
                    ClrBit(FOC_CR2,F5SEG);                              // 7æ®µå¼
                  }
                  #elif (SVPMW_Mode == SVPWM_5_Segment)
                  {
                    SetBit(FOC_CR2,F5SEG);                              // 7æ®µå¼
                  }
                  #endif //end SVPMW_Mode
              
                  #if (DouRes_Sample_Mode == DouRes_1_Cycle)
                  {
                    ClrBit(FOC_CR2,DSS);                              // 7æ®µå¼
                  }
                  #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 4   

                  {
                    SetBit(FOC_CR2,DSS);                              // 7æ®µå¼
                  }
                  #endif //end DouRes_Sample_Mode
                }
                #endif  //end Shunt_Resistor_Mode
 177   1      
 178   1      
 179   1        /* ä½¿èƒ½ç”µæµåŸºå‡†æ ¡æ­£ */
 180   1        #if (CalibENDIS == Enable)
 181   1        {
 182   2          if(mcCurOffset.OffsetFlag==1)
 183   2          {
 184   3            #if (Shunt_Resistor_Mode == Single_Resistor)        // å•ç”µé˜»æ ¡æ­£
 185   3            {
 186   4              /*set ibus current sample offset*/
 187   4              SetReg(FOC_CR2, CSOC0 | CSOC1, 0x00);
 188   4              FOC_CSO = mcCurOffset.Iw_busOffset;               // å†™å…¥Ibusçš„åç½®
 189   4      
 190   4            }
 191   3            #elif (Shunt_Resistor_Mode == Double_Resistor)      // åŒç”µé˜»æ ¡æ­£
                    {
                      /*set ia, ib current sample offset*/
                      SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC0);
                      FOC_CSO  = mcCurOffset.IuOffset;                  // å†™å…¥IAçš„åç½®
              
                      SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC1);
                      FOC_CSO  = mcCurOffset.IvOffset;                  // å†™å…¥IBçš„åç½®
              
                    }
                    #elif (Shunt_Resistor_Mode == Three_Resistor)       // ä¸‰ç”µé˜»æ ¡æ­£
                    {
                      /*set ibus current sample offset*/
                      SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC0);
                      FOC_CSO = mcCurOffset.IuOffset;                   // å†™å…¥IAçš„åç½®
              
                      SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC1);
                      FOC_CSO = mcCurOffset.IvOffset;                   // å†™å…¥IBçš„åç½®
              
                      SetReg(FOC_CR2, CSOC0 | CSOC1, 0x00);
                      FOC_CSO = mcCurOffset.Iw_busOffset;               // å†™å…¥ICçš„åç½®
                    }
                    #endif  //end Shunt_Resistor_Mode
 214   3          }
 215   2        }
 216   1        #endif  //end CalibENDIS
 217   1        /*-------------------------------------------------------------------------------------------------
 218   1        DRV_CTLï¼šPWMæ¥æºé€‰æ‹©
 219   1        OCS = 0, DRV_COMR
 220   1        OCS = 1, FOC/SVPWM/SPWM
 221   1        -------------------------------------------------------------------------------------------------*/
 222   1        /*è®¡æ•°å™¨æ¯”è¾ƒå€¼æ¥æºFOC*/
 223   1        SetBit(DRV_CR, OCS);
 224   1      }
 225          /*---------------------------------------------------------------------------*/
 226          /* Name   : void Motor_Charge(void)
 227          /* Input  : NO
 228          /* Output : NO
 229          /* Description: é¢„å……ç”µï¼Œå½“ä¸€ç›´å¤„äºé¢„å……ç”µçŠ¶æ€ä¸‹ï¼Œä¸æ¥ç”µæœºï¼Œå¯ç”¨äºéªŒè¯IPMæˆ–è€…Mos
             -ã€‚
 230          é¢„å……ç”µåˆ†ä¸‰æ­¥ï¼Œç¬¬ä¸€æ­¥æ˜¯å¯¹Uç›¸è¿›è¡Œé¢„å……ç”µï¼Œç¬¬äºŒæ­¥æ˜¯å¯¹U,Vä¸¤ç›¸è¿›è¡Œé¢„å……ç”µ;ç¬¬ä¸‰æ­
             -¥æ˜¯å¯¹Uã€Vã€Wä¸‰ç›¸è¿›è¡Œé¢„å……ç”µã€‚
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 5   

 231          /*---------------------------------------------------------------------------*/
 232          void Motor_Charge(void)
 233          {
 234   1           if(McStaSet.SetFlag.ChargeSetFlag==0)
 235   1           {
 236   2              McStaSet.SetFlag.ChargeSetFlag = 1;
 237   2              #if (PWM_Level_Mode == Low_Level)  //ç”¨äºæ¸¬è©¦6536
                      {
                       SetBit(P1_OE, P10);
                       GP10=1;
                      }
                      #endif
 243   2              #if (IPMState == IPMtest)
                       {
                         DRV_DR = 0.7*DRV_ARR;                // IPM 70% duty
                       }
                       #elif (IPMState == NormalRun)          // æ­£å¸¸æŒ‰ç”µæœºçŠ¶æ€æœºè¿è¡Œ
 248   2               {
 249   3                 DRV_DR = 0.1*DRV_ARR;                //ä¸‹æ¡¥è‡‚10% duty
 250   3               }
 251   2              #endif
 252   2              /*-------------------------------------------------------------------------------------------------
 253   2              DRV_CTLï¼šPWMæ¥æºé€‰æ‹©
 254   2              OCS = 0, DRV_COMR
 255   2              OCS = 1, FOC/SVPWM/SPWM
 256   2              -------------------------------------------------------------------------------------------------*/
 257   2              ClrBit(DRV_CR, OCS);
 258   2              mcFocCtrl.ChargeStep = 0;
 259   2           }
 260   1           if((mcFocCtrl.State_Count < Charge_Time)&&(mcFocCtrl.ChargeStep == 0))
 261   1           {
 262   2             mcFocCtrl.ChargeStep = 1;
 263   2             #if (IPMState == IPMtest)
                     {
                       DRV_CMR |= 0x03;                         // Uç›¸è¾“å‡º
                     }
                     #elif (IPMState == NormalRun)              // æ­£å¸¸æŒ‰ç”µæœºçŠ¶æ€æœºè¿è¡Œ
 268   2             {
 269   3               DRV_CMR |= 0x01;                         // Uç›¸ä¸‹æ¡¥è‡‚é€š
 270   3             }
 271   2             #endif
 272   2             MOE = 1;
 273   2           }
 274   1           if(( mcFocCtrl.State_Count <= (Charge_Time<<1)/3)&&(mcFocCtrl.ChargeStep== 1))
 275   1           {
 276   2             mcFocCtrl.ChargeStep = 2;
 277   2             #if (IPMState == IPMtest)
                     {
                       DRV_CMR |= 0x0F;                         // Uã€Vç›¸è¾“å‡º
                     }
                     #elif (IPMState == NormalRun)              // æ­£å¸¸æŒ‰ç”µæœºçŠ¶æ€æœºè¿è¡Œ
 282   2             {
 283   3               DRV_CMR |= 0x04;                         // Vç›¸ä¸‹æ¡¥è‡‚å¯¼é€š
 284   3             }
 285   2             #endif
 286   2           }
 287   1           if((mcFocCtrl.State_Count <= Charge_Time/3)&&(mcFocCtrl.ChargeStep== 2))
 288   1           {
 289   2              mcFocCtrl.ChargeStep = 3;
 290   2             #if (IPMState == IPMtest)
                     {
                       DRV_CMR |= 0x3F;                         // Uã€Vã€Wç›¸è¾“å‡º
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 6   

                     }
                     #elif (IPMState == NormalRun)              // æ­£å¸¸æŒ‰ç”µæœºçŠ¶æ€æœºè¿è¡Œ
 295   2             {
 296   3               DRV_CMR |= 0x10;                         // Wç›¸ä¸‹æ¡¥è‡‚å¯¼é€š
 297   3             }
 298   2             #endif
 299   2           }
 300   1      }
 301          /*---------------------------------------------------------------------------*/
 302          /* Name   : void Motor_Align(void)
 303          /* Input  : NO
 304          /* Output : NO
 305          /* Description: é¢„å®šä½å‡½æ•°ï¼Œå½“æ— é€†é£åˆ¤æ–­æ—¶ï¼Œé‡‡ç”¨é¢„å®šä½å›ºå®šåˆå§‹ä½ç½®;å½“æœ‰é€†é£åˆ
             -¤æ–­æ—¶ï¼Œé‡‡ç”¨é¢„å®šä½åˆ¹è½¦
 306          /*---------------------------------------------------------------------------*/
 307          void Motor_Align(void)
 308          {
 309   1        if(McStaSet.SetFlag.AlignSetFlag==0)
 310   1        {
 311   2            McStaSet.SetFlag.AlignSetFlag=1;
 312   2      
 313   2            /*FOCåˆå§‹åŒ–*/
 314   2            FOC_Init();
 315   2      
 316   2            /*é…ç½®é¢„å®šä½çš„ç”µæµã€KPã€KI*/
 317   2            FOC_IDREF = ID_Align_CURRENT;
 318   2            FOC_IQREF = IQ_Align_CURRENT;
 319   2      
 320   2            FOC_DQKP = DQKP_Alignment;
 321   2            FOC_DQKI = DQKI_Alignment;
 322   2      
 323   2            FOC_EKP   = OBSW_KP_GAIN;
 324   2            FOC_EKI   = OBSW_KI_GAIN;
 325   2      
 326   2            /*é…ç½®é¢„å®šä½è§’åº¦*/
 327   2            #if (AlignTestMode==1)
                    {
                      FOC__THETA    = Align_Theta;
                    }
                    #else
 332   2            {
 333   3              #if (PosCheckEnable==1)
 334   3              {
 335   4                FOC__THETA  = mcFocCtrl.mcPosCheckAngle + _Q15((float)60.0/180.0);
 336   4      //          if(FOC__THETA >= _Q15((float)180.0/180.0))
 337   4      //          {
 338   4      //            FOC__THETA  = FOC__THETA - _Q15((float)240.0/180.0);
 339   4      //          }
 340   4                
 341   4              }
 342   3              #else
                      {
                        FOC__THETA    =Align_Theta;
                      }
                      #endif  //end PosCheckEnable
 347   3            }
 348   2            #endif  //end AlignTestMode
 349   2                  /*********PLLæˆ–SMO**********/
 350   2            #if (EstimateAlgorithm == SMO)
 351   2            {
 352   3              FOC__ETHETA   = FOC__THETA-4096;
 353   3            }
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 7   

 354   2            #elif (EstimateAlgorithm == PLL)
                    {
                      FOC__ETHETA   = FOC__THETA;
                    }
                    #endif //end  EstimateAlgorithm
 359   2            TimeCnt=FOC__THETA;
 360   2      
 361   2            /*ä½¿èƒ½è¾“å‡º*/
 362   2            DRV_CMR |= 0x3F;                         // Uã€Vã€Wç›¸è¾“å‡º
 363   2            MOE = 1;
 364   2      
 365   2        }
 366   1      }
 367          
 368          /*---------------------------------------------------------------------------*/
 369          /* Name   : void Motor_Open(void)
 370          /* Input  : NO
 371          /* Output : NO
 372          /* Description: å¼€ç¯å¯åŠ¨çš„å‚æ•°é…ç½®
 373          /*---------------------------------------------------------------------------*/
 374          void Motor_Open(void)
 375          {
 376   1          static uint8 OpenRampCycles;
 377   1          if(McStaSet.SetFlag.StartSetFlag==0)
 378   1          {
 379   2            McStaSet.SetFlag.StartSetFlag=1;
 380   2      
 381   2      
 382   2            /****å¯åŠ¨åˆå§‹è§’åº¦èµ‹å€¼**/
 383   2            #if (PosCheckEnable)
 384   2            {
 385   3              FOC__THETA  = mcFocCtrl.mcPosCheckAngle;// æœ‰åˆå§‹ä½ç½®æ£€æµ‹ï¼Œåˆ™ç”¨åˆå§‹ä½ç½®è§’
 386   3            }
 387   2            #else
                    {
                      FOC__THETA    = Align_Theta;            // æ— åˆå§‹ä½ç½®æ£€æµ‹ï¼Œåˆ™ç”¨é¢„å®šä½è§’
                    }
                    #endif
 392   2            /*********PLLæˆ–SMO**********/
 393   2            #if (EstimateAlgorithm == SMO)
 394   2            {
 395   3              FOC__ETHETA   = FOC__THETA-4915;
 396   3            }
 397   2            #elif (EstimateAlgorithm == PLL)
                    {
                      FOC__ETHETA   = FOC__THETA;
                    }
                    #endif //end  EstimateAlgorithm
 402   2      
 403   2            TimeCnt=FOC__ETHETA;
 404   2            /*å¯åŠ¨ç”µæµã€KPã€KIã€FOC_EKPã€FOC_EKI*/
 405   2            FOC_IDREF = ID_Start_CURRENT;                         // Dè½´å¯åŠ¨ç”µæµ
 406   2            mcFocCtrl.mcIqref= IQ_Start_CURRENT;                  // Qè½´å¯åŠ¨ç”µæµ
 407   2      
 408   2           #if (FRDetectMethod==BEMFMethod)
                    {
                      if(BEMFDetect.BEMFCCWFlag==1)
                      {
                        mcFocCtrl.mcIqref+=I_Value(0.95);                    //é€†é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
                      }
                      else if(BEMFDetect.BEMFCCWFlag==2)
                      {
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 8   

                        mcFocCtrl.mcIqref+=I_Value(0.8);                    //é€†é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
                      }
                    }
                    #endif
 420   2            #if (FRDetectMethod==RSDMethod)
                    {
                      if((RSDDetect.RSDCCWFlag==1)||(RSDDetect.RSDCCWTimes>=4))
                      {
                        mcFocCtrl.mcIqref+=I_Value(0.95);                    //é€†é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
                      }
                      else if(RSDDetect.RSDCCWFlag==2)
                      {
                        mcFocCtrl.mcIqref+=I_Value(0.9);                    //é€†é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
                      }
                    }
                    #endif
 432   2      
 433   2      //      FOC_DQKP = DQKP;
 434   2      //      FOC_DQKI = DQKI;
 435   2            FOC_DQKP  = DQKPStart;
 436   2            FOC_DQKI  = DQKIStart;        
 437   2      
 438   2            //å¯åŠ¨æ—¶è®¾ç½®Qè½´PIä¸‹é™èµ·å§‹å€¼
 439   2            FOC_QMAX      =  QOUTMAX;
 440   2            FOC_QMIN      = QOUTMIN;
 441   2            
 442   2            FOC_EKP   = OBSW_KP_GAIN;
 443   2            FOC_EKI   = OBSW_KI_GAIN;
 444   2      
 445   2            
 446   2            /*å¯åŠ¨æ–¹å¼é€‰æ‹©*/
 447   2            #if (Open_Start_Mode == Omega_Start)                  // Omega å¯åŠ¨
 448   2            {
 449   3              FOC_EFREQACC  = Motor_Omega_Ramp_ACC;
 450   3              FOC_EFREQMIN  = Motor_Omega_Ramp_Min;
 451   3              FOC_EFREQHOLD = Motor_Omega_Ramp_End;
 452   3      
 453   3              SetBit(FOC_CR1,EFAE);                             // ä¼°ç®—å™¨å¼ºåˆ¶è¾“å‡º
 454   3              ClrBit(FOC_CR1,RFAE);                             // ç¦æ­¢å¼ºæ‹‰
 455   3              SetBit(FOC_CR1,ANGM);                             // ä¼°ç®—æ¨¡å¼
 456   3            }
 457   2            #elif (Open_Start_Mode == Open_Start)
                    {
                      FOC_RTHEACC   = Motor_Open_Ramp_ACC;                      // çˆ¬å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
                      FOC__RTHESTEP   = Motor_Open_Ramp_Min;                // 0.62 degree acce speed
                      RPDPara.ThetaGet=Motor_Open_Ramp_Min;
                      FOC__RTHECNT  = MOTOR_OPEN_ACC_CNT;                 // acce time
              
                      ClrBit(FOC_CR1,EFAE);                             // ä¼°ç®—å™¨å¼ºåˆ¶è¾“å‡º
                      SetBit(FOC_CR1,RFAE);                             // ç¦æ­¢å¼ºæ‹‰
                      ClrBit(FOC_CR1,ANGM);                             // ä¼°ç®—æ¨¡å¼
                    }
                    #elif (Open_Start_Mode == Open_Omega_Start)
                    {
                      FOC_RTHEACC   = Motor_Open_Ramp_ACC;                      // çˆ¬å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
                      FOC__RTHESTEP   = Motor_Open_Ramp_Min;                // 0.62 degree acce speed
                      FOC__RTHECNT  = MOTOR_OPEN_ACC_CNT;                 // acce time
              
                      FOC_EFREQACC  = Motor_Omega_Ramp_ACC;
                      FOC_EFREQMIN  = Motor_Omega_Ramp_Min;
                      FOC_EFREQHOLD = Motor_Omega_Ramp_End;
              
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 9   

                      SetBit(FOC_CR1,EFAE);                             // ä¼°ç®—å™¨å¼ºåˆ¶è¾“å‡º
                      SetBit(FOC_CR1,RFAE);                             // ç¦æ­¢å¼ºæ‹‰
                      SetBit(FOC_CR1,ANGM);                             // ä¼°ç®—æ¨¡å¼
                    }
                    #endif //end Open_Start_Mode
 483   2            
 484   2          }
 485   1            /*ä¸åŒå¯åŠ¨æ–¹å¼ä¸‹ï¼Œåˆ‡æ¢åˆ°MCRUNçŠ¶æ€*/
 486   1            #if (Open_Start_Mode == Open_Start)     //OPENçŠ¶æ€å¯åŠ¨æ—¶æ‹–åŠ¨å¤šæ¬¡
                    {
                      if(OpenRampCycles<(MOTOR_OPEN_ACC_CYCLE-1))
                      {
                        if(!ReadBit(FOC_CR1,RFAE))
                        {
                          SetBit(FOC_CR1,RFAE);
                          OpenRampCycles++;
                        }
                      }
                      else
                      {
                        mcFocCtrl.State_Count = 2;
              
                        mcState = mcRun;
                      }
                        FOC_EKP = OBSW_KP_GAIN_RUN4;                          // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
                        FOC_EKI = OBSW_KI_GAIN_RUN4;                          // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
                    }
                    #elif (Open_Start_Mode == Open_Omega_Start)
                    {
                        mcFocCtrl.State_Count = 200;
                        mcState = mcRun;
                    }
                    #elif (Open_Start_Mode == Omega_Start)
 511   1            {
 512   2              /*********PLLæˆ–SMO**********/
 513   2              #if (EstimateAlgorithm == SMO)
 514   2              {
 515   3                 mcFocCtrl.State_Count = 120;
 516   3              }
 517   2              #elif (EstimateAlgorithm == PLL)
                      {
                        FOC_EKP = OBSW_KP_GAIN_RUN4;                          // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
                        FOC_EKI = OBSW_KI_GAIN_RUN4;                          // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
                      }
                      #endif //end  EstimateAlgorithm
 523   2              mcState = mcRun;
 524   2            }
 525   1            #endif //end Open_Start_Mode
 526   1            
 527   1            FOC_IQREF = mcFocCtrl.mcIqref;                        // Qè½´å¯åŠ¨ç”µæµ
 528   1      }
 529          
 530          /*---------------------------------------------------------------------------*/
 531          /* Name   : void Motor_Open(void)
 532          /* Input  : NO
 533          /* Output : NO
 534          /* Description: å¼€ç¯å¯åŠ¨çš„å‚æ•°é…ç½®
 535          /*---------------------------------------------------------------------------*/
 536          void Motor_PllStart(void)
 537          {
 538   1          static uint8 OpenRampCycles;
 539   1          if(TailWindDetect.PLLFlag==1)
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 10  

 540   1          {
 541   2            TailWindDetect.PLLSpeed=FOC__EOME;
 542   2            if(Abs_F16(TailWindDetect.PLLSpeed)<100)//é€†é£çŠ¶æ€ä¸‹ï¼Œé€Ÿåº¦ä½äº100æ—¶ï¼Œè®¡æ•°ï¼Œè¾¾åˆ°ä¸€å®šæ
             -—¶é—´åï¼ŒPLLFlagæ¸…é›¶ã€‚
 543   2            {
 544   3              TailWindDetect.PLLDetectCnt++;
 545   3              if(TailWindDetect.PLLDetectCnt>3000)//é˜²æ­¢ä¼°ç®—é”™è¯¯
 546   3              {
 547   4                TailWindDetect.PLLFlag=0;
 548   4                TailWindDetect.PLLTheta=FOC__ETHETA;
 549   4                FOC_IQREF =0;
 550   4              }
 551   3            }
 552   2            else
 553   2            {
 554   3              if(TailWindDetect.PLLDetectCnt>0)
 555   3              {
 556   4                TailWindDetect.PLLDetectCnt--;
 557   4              }
 558   3            }
 559   2          }
 560   1          if((McStaSet.SetFlag.StartSetFlag==0)&&(TailWindDetect.PLLFlag==0))
 561   1          {
 562   2            McStaSet.SetFlag.StartSetFlag=1;
 563   2            MOE = 0;
 564   2            FOC_Init();
 565   2            FOC__ETHETA   = TailWindDetect.PLLTheta+19000;//16668;//
 566   2      
 567   2            /*å¯åŠ¨ç”µæµã€KPã€KIã€FOC_EKPã€FOC_EKI*/
 568   2            FOC_IDREF = ID_Start_CURRENT;                         // Dè½´å¯åŠ¨ç”µæµ
 569   2            FOC_IQREF = mcFocCtrl.mcIqref;                        // Qè½´å¯åŠ¨ç”µæµ
 570   2      
 571   2            FOC_DQKP = DQKP;
 572   2            FOC_DQKI = DQKI;
 573   2      
 574   2            /*å¯åŠ¨æ–¹å¼é€‰æ‹©*/
 575   2            #if (Open_Start_Mode == Omega_Start)                  // Omega å¯åŠ¨
 576   2            {
 577   3              FOC_EFREQACC  = Motor_Omega_Ramp_ACC;
 578   3              FOC_EFREQMIN  = Motor_Omega_Ramp_Min;
 579   3              FOC_EFREQHOLD = Motor_Omega_Ramp_End;
 580   3      
 581   3              SetBit(FOC_CR1,EFAE);                             // ç¦æ­¢ä¼°ç®—å™¨å¼ºåˆ¶è¾“å‡º
 582   3              ClrBit(FOC_CR1,RFAE);                             // ä½¿èƒ½å¼ºæ‹‰
 583   3              SetBit(FOC_CR1,ANGM);                             // ä¼°ç®—æ¨¡å¼
 584   3            }
 585   2            #elif (Open_Start_Mode == Open_Start)
                    {
                      FOC_RTHEACC   = Motor_Open_Ramp_ACC;                      // çˆ¬å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
                      FOC__RTHESTEP   = Motor_Open_Ramp_Min;                // 0.62 degree acce speed
                      FOC__RTHECNT  = MOTOR_OPEN_ACC_CNT;                 // acce time
              
                      ClrBit(FOC_CR1,EFAE);                             // ç¦æ­¢ä¼°ç®—å™¨å¼ºåˆ¶è¾“å‡º
                      SetBit(FOC_CR1,RFAE);                             // ä½¿èƒ½å¼ºæ‹‰
                      ClrBit(FOC_CR1,ANGM);                             // ä¼°ç®—æ¨¡å¼
                    }
                    #elif (Open_Start_Mode == Open_Omega_Start)
                    {
                      FOC_RTHEACC   = Motor_Open_Ramp_ACC;                      // çˆ¬å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
                      FOC__RTHESTEP   = Motor_Open_Ramp_Min;                // 0.62 degree acce speed
                      FOC__RTHECNT  = MOTOR_OPEN_ACC_CNT;                 // acce time
              
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 11  

                      FOC_EFREQACC  = Motor_Omega_Ramp_ACC;
                      FOC_EFREQMIN  = Motor_Omega_Ramp_Min;
                      FOC_EFREQHOLD = Motor_Omega_Ramp_End;
              
                      SetBit(FOC_CR1,EFAE);                             // ç¦æ­¢ä¼°ç®—å™¨å¼ºåˆ¶è¾“å‡º
                      SetBit(FOC_CR1,RFAE);                             // ä½¿èƒ½å¼ºæ‹‰
                      SetBit(FOC_CR1,ANGM);                             // ä¼°ç®—æ¨¡å¼
                    }
                    #endif //end Open_Start_Mode
 610   2            DRV_CMR |= 0x3F;                         // Uã€Vã€Wç›¸è¾“å‡º
 611   2            MOE = 1;
 612   2          }
 613   1      
 614   1          if((McStaSet.SetFlag.StartSetFlag==1)&&(TailWindDetect.PLLFlag==0))
 615   1          {
 616   2            /*ä¸åŒå¯åŠ¨æ–¹å¼ä¸‹ï¼Œåˆ‡æ¢åˆ°MCRUNçŠ¶æ€*/
 617   2            #if (Open_Start_Mode == Open_Start)     //OPENçŠ¶æ€å¯åŠ¨æ—¶æ‹–åŠ¨å¤šæ¬¡
                    {
                      if(OpenRampCycles<(MOTOR_OPEN_ACC_CYCLE-1))
                      {
                        if(!ReadBit(FOC_CR1,RFAE))
                        {
                          SetBit(FOC_CR1,RFAE);
                          OpenRampCycles++;
                        }
                      }
                      else
                      {
                        mcFocCtrl.State_Count = 2;
                        mcState = mcRun;
                      }
                        FOC_EKP = OBSW_KP_GAIN_RUN4;                          // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
                        FOC_EKI = OBSW_KI_GAIN_RUN4;                          // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
                    }
                    #elif (Open_Start_Mode == Open_Omega_Start)
                    {
                        mcFocCtrl.State_Count = 2600;
                        mcState = mcRun;
                    }
                    #elif (Open_Start_Mode == Omega_Start)
 641   2            {
 642   3      
 643   3                FOC_EKP = OBSW_KP_GAIN_RUN4;                          // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
 644   3                FOC_EKI = OBSW_KI_GAIN_RUN4;                          // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
 645   3                mcState = mcRun;
 646   3            }
 647   2            #endif //end Open_Start_Mode
 648   2          }
 649   1      
 650   1      }
 651          /*---------------------------------------------------------------------------*/
 652          /* Name   : void Motor_Align(void)
 653          /* Input  : NO
 654          /* Output : NO
 655          /* Description: é¡ºé£é€†é£å‚æ•°é…ç½®å‡½æ•°
 656          /*---------------------------------------------------------------------------*/
 657          void Motor_TailWind(void)
 658          {
 659   1        if(mcFocCtrl.State_Count == 0)
 660   1        {
 661   2          if(McStaSet.SetFlag.TailWindSetFlag  ==0)//åˆå§‹åŒ–
 662   2          {
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 12  

 663   3              McStaSet.SetFlag.TailWindSetFlag =1;
 664   3      
 665   3              #if (FRDetectMethod==RSDMethod)
                       {
                         RSDDetectInit();
                       }
                      #elif (FRDetectMethod==BEMFMethod)
                       {
                         BEMFDetectInit();
                       }
                      #elif (FRDetectMethod==FOCMethod)
 674   3               {
 675   4                 TailWindDetectInit();
 676   4               }
 677   3              #endif
 678   3      
 679   3          }
 680   2          #if (FRDetectMethod==RSDMethod)
                  {
                    RSDDealwith();
                  }
                  #elif (FRDetectMethod==BEMFMethod)
                  {
                    BEMFDealwith();
                  }
                  #elif (FRDetectMethod==FOCMethod)
 689   2          {
 690   3            FOCTailWindDealwith();
 691   3          }
 692   2         #endif
 693   2      
 694   2        }
 695   1      }
 696          
 697          /*---------------------------------------------------------------------------*/
 698          /* Name   : void MC_Stop(void)
 699          /* Input  : NO
 700          /* Output : NO
 701          /* Description: inital motor control parameter
 702          /*---------------------------------------------------------------------------*/
 703          void MC_Stop(void)
 704          {
 705   1        MOE     = 0;
 706   1        ClrBit(DRV_CR, FOCEN, 0); //å…³é—­FOC                                                     // disable FOC output and initial registe
             -r
 707   1        mcState = mcInit;
 708   1      }
 709          
 710          /*-------------------------------------------------------------------------------------------------
 711            Function Name : void MotorControlInit(void)
 712            Description   : æ§åˆ¶å˜é‡åˆå§‹åŒ–æ¸…é›¶,åŒ…æ‹¬ä¿æŠ¤å‚æ•°çš„åˆå§‹åŒ–ã€ç”µæœºçŠ¶æ€åˆå§‹åŒ–
 713            Input         : è¾“å…¥è¯´æ˜ï¼ˆè¯¦ç»†ï¼‰
 714            Output        : è¾“å‡ºè¯´æ˜ï¼ˆè¯¦ç»†ï¼‰
 715          -------------------------------------------------------------------------------------------------*/
 716          void MotorcontrolInit(void)
 717          {
 718   1        /***********ä¿æŠ¤******************/
 719   1        memset(&mcFaultDect,0, sizeof(FaultVarible));                               // FaultVaribleå˜é‡æ¸…é›¶
 720   1        /******å µè½¬ä¿æŠ¤*********/
 721   1      //  mcFaultDect.StallRecover          = 1000;//5s
 722   1      
 723   1        /******ä¿æŠ¤æ¬¡æ•°*********/
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 13  

 724   1        memset(&mcProtectTime,0, sizeof(ProtectVarible));                           // ProtectVaribleä¿æŠ¤æ¬¡æ•°æ¸…é›¶ 
 725   1        /*******è¿‡æµä¿æŠ¤*****************/
 726   1        memset(&mcCurVarible,0, sizeof(CurrentVarible));                            // ç”µæµä¿æŠ¤çš„å˜é‡æ¸…é›¶
 727   1      
 728   1        /*****é¡ºé€†é£åˆ¤æ–­ï¼ŒFOCMethodä¸éœ€è¦åœ¨æ­¤èµ‹åˆå€¼*******/
 729   1        #if (FRDetectMethod==RSDMethod)
                {
                 memset(&RSDDetect,0, sizeof(MotorRSDTypeDef)); //  RSDDetectæ‰€æœ‰å˜é‡æ¸…é›¶
                }
                #elif (FRDetectMethod==BEMFMethod)
                {
                 memset(&BEMFDetect,0, sizeof(BEMFDetect_TypeDef));   //  BEMFDetectæ‰€æœ‰å˜é‡æ¸…é›¶
                } 
                #endif
 738   1      
 739   1        /*******å¯åœæµ‹è¯•çš„å‚æ•°***************/
 740   1        memset(&ONOFFTest,0, sizeof(ONVarible));
 741   1      
 742   1        /*****ç”µæœºçŠ¶æ€æœºæ—¶åºå˜é‡***********/
 743   1        McStaSet.SetMode                   = 0;
 744   1      
 745   1        /*****ç”µæœºç›®æ ‡æ–¹å‘**********/
 746   1        mcFRState.TargetFR                 = 0;
 747   1      
 748   1        /*****å¤–éƒ¨æ§åˆ¶ç¯*******/
 749   1        memset(&mcFocCtrl,0, sizeof(FOCCTRL));                                // mcFocCtrlå˜é‡æ¸…é›¶
 750   1      
 751   1        /******ADCé‡‡æ ·æ»¤æ³¢å€¼*********/
 752   1        memset(&AdcSampleValue,0, sizeof(ADCSample));                         // ADCSampleå˜é‡æ¸…é›¶
 753   1      
 754   1        /******ç”µæµåç½®æ ¡å‡†å˜é‡*****/
 755   1        memset(&mcCurOffset,0, sizeof(CurrentOffset));                        // mcCurOffsetå˜é‡æ¸…é›¶
 756   1        mcCurOffset.IuOffsetSum            = 16383;
 757   1        mcCurOffset.IvOffsetSum            = 16383;
 758   1        mcCurOffset.Iw_busOffsetSum        = 16383;
 759   1      
 760   1        /*****LEDç¯å“åº”***/
 761   1        memset(&mcLedDisplay,0, sizeof(MCLedDisplay));                        // mcLedDisplayå˜é‡æ¸…é›¶
 762   1        mcLedDisplay.Counttime            = 4999;
 763   1      
 764   1        /*****é€Ÿåº¦ç¯çš„å“åº”***/
 765   1        memset(&mcSpeedRamp,0, sizeof(MCRAMP));                               // mcSpeedRampå˜é‡æ¸…é›¶
 766   1      //  mcSpeedRamp.IncValue              = Motor_Speed_Inc;
 767   1      //  mcSpeedRamp.DecValue              = Motor_Speed_Dec;
 768   1        mcSpeedRamp.DelayPeriod           = 1;
 769   1      
 770   1        /*PWMè°ƒé€Ÿå˜é‡*/
 771   1        memset(&mcPwmInput,0, sizeof(PWMINPUTCAL));                                   // æ¸…é›¶PWM duty è°ƒé€Ÿå˜é‡mcPwmInput
 772   1        memset(&mcPWMFreqInputCtrl,0, sizeof(PWMFREQINPUTTRPE));                                // æ¸…é›¶PWM è°ƒé¢‘è°ƒé€Ÿå˜é‡PW
             -MINCtl
 773   1      
 774   1        /*ä¸²å£å˜é‡*/
 775   1        memset(&Uart,0, sizeof(MCUART));                                              // MCUARTå˜é‡æ¸…é›¶
 776   1      
 777   1        /*ç¡çœ æ¨¡å¼*/  
 778   1        memset(&SleepSet,0, sizeof(SLEEPMODE));                                       // ç¡çœ æ¨¡å¼æ¸…é›¶
 779   1      
 780   1      //
 781   1        Time.Start_CNT                     = 0;
 782   1        Time.UnderVoltageCount             = 0;
 783   1      }
 784          
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 14  

 785          /*---------------------------------------------------------------------------*/
 786          /* Name   : void VariablesPreInit(void)
 787          /* Input  : NO
 788          /* Output : NO
 789          /* Description: åˆå§‹åŒ–ç”µæœºå‚æ•°
 790          /*---------------------------------------------------------------------------*/
 791          void VariablesPreInit(void)
 792          {
 793   1        /***********ä¿æŠ¤******************/
 794   1        mcFaultSource = 0;
 795   1        memset(&mcFaultDect,0, sizeof(FaultVarible));                                 // FaultVaribleå˜é‡æ¸…é›¶
 796   1      
 797   1        /*****å¤–éƒ¨æ§åˆ¶ç¯*******/
 798   1        memset(&mcFocCtrl,0, sizeof(FOCCTRL));                                        // mcFocCtrlå˜é‡æ¸…é›¶
 799   1      
 800   1        /*****é¡ºé€†é£åˆ¤æ–­*******/
 801   1        #if (FRDetectMethod==RSDMethod)
                {
                  RSDDetect.RSDCCWTimes    = 0;                                               //  CCWåˆ¹è½¦æ¬¡æ•°æ¸…é›¶
                }
                #elif (FRDetectMethod==BEMFMethod)
                {
                }
                #elif (FRDetectMethod==FOCMethod)
 809   1        {
 810   2          memset(&TailWindDetect,0, sizeof(MotorTailWindTypeDef));                    //  TailWindDetectæ‰€æœ‰å˜é‡æ¸…é›¶
 811   2        }
 812   1        #endif
 813   1        /*****ç”µæœºçŠ¶æ€æœºæ—¶åºå˜é‡***********/
 814   1        McStaSet.SetMode                   = 0;
 815   1      
 816   1        /*****LEDç¯å“åº”***/
 817   1        memset(&mcLedDisplay,0, sizeof(MCLedDisplay));                                // mcLedDisplayå˜é‡æ¸…é›¶
 818   1        mcLedDisplay.Counttime            = 4999;
 819   1      
 820   1        //å µè½¬ä¿æŠ¤ç”µæµå€¼è®¾ç½®
 821   1       // mcFaultDect.StallCurrentVale       = StallCurrentValue1;
 822   1      }
 823          /*---------------------------------------------------------------------------*/
 824          /* Name   : void GetCurrentOffset(void)
 825          /* Input  : NO
 826          /* Output : NO
 827          /* Description: ä¸Šç”µæ—¶ï¼Œå…ˆå¯¹ç¡¬ä»¶ç”µè·¯çš„ç”µæµè¿›è¡Œé‡‡é›†ï¼Œå†™å…¥å¯¹åº”çš„æ ¡å‡†å¯„å­˜å™¨ä¸­ã€‚
 828                          è°ƒè¯•æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffsetç»“æ„ä½“ä¸­å¯¹åº”å˜é‡æ˜¯å¦åœ¨èŒƒå›´å†…ã€‚é‡‡é›†ç»“æŸåï¼ŒOff
             -setFlagç½®1ã€‚
 829          /*---------------------------------------------------------------------------*/
 830          void GetCurrentOffset(void)
 831          {
 832   1        if(mcCurOffset.OffsetFlag==0)
 833   1        {      
 834   2          SetBit(ADC_CR, ADCBSY);                              // ä½¿èƒ½ADC
 835   2          while(ReadBit(ADC_CR, ADCBSY));
 836   2          #if (Shunt_Resistor_Mode == Single_Resistor)             // 29.2ms å•ç”µé˜»æ¨¡å¼ï¼Œä¸Šç”µéªŒè¯ç¡¬ä»¶ç”µè
             -·¯æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffset.IbusOffsetæ˜¯å¦ä¸º4096
 837   2          {
 838   3            mcCurOffset.Iw_busOffsetSum+=((ADC4_DR& 0x0fff) << 3);
 839   3            mcCurOffset.Iw_busOffset = mcCurOffset.Iw_busOffsetSum >> 4;
 840   3            mcCurOffset.Iw_busOffsetSum -= mcCurOffset.Iw_busOffset;
 841   3          }
 842   2          #elif (Shunt_Resistor_Mode == Double_Resistor)           //44ms åŒç”µé˜»æ¨¡å¼ï¼Œä¸Šç”µéªŒè¯ç¡¬ä»¶ç”µè·¯æ—
             -¶ï¼Œéœ€è§‚å¯ŸmcCurOffset.IaOffsetã€mcCurOffset.IbOffsetæ˜¯å¦ä¸º4096
                  {
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 15  

                    mcCurOffset.IuOffsetSum+=((ADC0_DR& 0x0fff) << 3);
                    mcCurOffset.IuOffset = mcCurOffset.IuOffsetSum >> 4;
                    mcCurOffset.IuOffsetSum -= mcCurOffset.IuOffset;
              
                    mcCurOffset.IvOffsetSum+=((ADC1_DR& 0x0fff) << 3);
                    mcCurOffset.IvOffset = mcCurOffset.IvOffsetSum >> 4;
                    mcCurOffset.IvOffsetSum -= mcCurOffset.IvOffset;
              
                  }
                  #elif (Shunt_Resistor_Mode == Three_Resistor)           //58.2ms ä¸‰ç”µé˜»æ¨¡å¼ï¼Œä¸Šç”µéªŒè¯ç¡¬ä»¶ç”µè·
             -¯æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffset.IaOffsetã€mcCurOffset.IbOffsetã€mcCurOffset.IcOffsetæ˜¯å¦ä¸º4096
                  {
                    mcCurOffset.IuOffsetSum+=((ADC0_DR& 0x0fff) << 3);
                    mcCurOffset.IuOffset = mcCurOffset.IuOffsetSum >> 4;
                    mcCurOffset.IuOffsetSum -= mcCurOffset.IuOffset;
              
                    mcCurOffset.IvOffsetSum+=((ADC1_DR& 0x0fff) << 3);
                    mcCurOffset.IvOffset = mcCurOffset.IvOffsetSum >> 4;
                    mcCurOffset.IvOffsetSum -= mcCurOffset.IvOffset;
              
                    mcCurOffset.Iw_busOffsetSum+=((ADC4_DR& 0x0fff) << 3);
                    mcCurOffset.Iw_busOffset = mcCurOffset.Iw_busOffsetSum >> 4;
                    mcCurOffset.Iw_busOffsetSum -= mcCurOffset.Iw_busOffset;
                  }
                  #endif
 868   2      
 869   2          mcCurOffset.OffsetCount++;
 870   2          if(mcCurOffset.OffsetCount>Calib_Time)
 871   2          {
 872   3            mcCurOffset.OffsetFlag=1;
 873   3          }
 874   2        }
 875   1      }
 876          /*---------------------------------------------------------------------------*/
 877          /* Name   : void Motor_Ready(void)
 878          /* Input  : NO
 879          /* Output : NO
 880          /* Description: ä¸Šç”µæ—¶ï¼Œå…³é—­è¾“å‡ºï¼Œå…ˆå¯¹ç¡¬ä»¶ç”µè·¯çš„ç”µæµè¿›è¡Œé‡‡é›†ï¼Œåœ¨FOC_Initä¸­å†™å…¥å
             -¯¹åº”çš„æ ¡å‡†å¯„å­˜å™¨ä¸­ã€‚
 881                          è°ƒè¯•æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffsetç»“æ„ä½“ä¸­å¯¹åº”å˜é‡æ˜¯å¦åœ¨èŒƒå›´å†…ã€‚
 882          /*---------------------------------------------------------------------------*/
 883          void Motor_Ready(void)
 884          {
 885   1         if(McStaSet.SetFlag.CalibFlag==0)
 886   1         {
 887   2           McStaSet.SetFlag.CalibFlag=1;
 888   2           ClrBit(DRV_CR, FOCEN);      // å…³é—­FOC
 889   2           MOE      = 0;               // å…³é—­MOE
 890   2           SetBit(ADC_MASK_SYSC, CH7EN |CH4EN | CH3EN | CH2EN | CH1EN | CH0EN);// å¼€å¯ADC
 891   2           mcCurOffset.OffsetFlag=0;   // å¼€å§‹ç”µæµé‡‡é›†
 892   2         }
 893   1      }
 894          /*---------------------------------------------------------------------------*/
 895          /* Name   : void Motor_Init(void)
 896          /* Input  : NO
 897          /* Output : NO
 898          /* Description: å¯¹ç”µæœºç›¸å…³å˜é‡ã€PIè¿›è¡Œåˆå§‹åŒ–è®¾ç½®
 899          /*---------------------------------------------------------------------------*/
 900          void Motor_Init(void)
 901          {
 902   1         ClrBit(ADC_MASK_SYSC, CH4EN |  CH1EN | CH0EN);// å…³é—­è½¯ä»¶ç”µæµé‡‡æ ·çš„ADC
 903   1         VariablesPreInit();                           // ç”µæœºç›¸å…³å˜é‡åˆå§‹åŒ–
C51 COMPILER V9.52.0.0   FOCCONTROLFUNCTION                                                04/16/2020 10:07:49 PAGE 16  

 904   1         PI_Init();                                    // PIåˆå§‹åŒ–
 905   1         User.Temperature   = 0;
 906   1      }
 907          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1840    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     23    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
